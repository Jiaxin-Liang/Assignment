Index: ../chap 4/4.1/neillncurses.c
===================================================================
--- ../chap 4/4.1/neillncurses.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/neillncurses.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,187 +0,0 @@
-#include "neillncurses.h"
-
-void Neill_NCURS_Delay(double ms){
-
-    const clock_t start = clock();
-    clock_t current;
-    do{
-        current = clock();
-    }while((double)(current-start)/CLOCKS_PER_SEC < (ms/1000.0));
-
-}
-
-/* Display a warning (.e.g array too large to fit on screen */
-void Neill_NCURS_Warning(char *s)
-{
-
-   int i, lx, ln;
-   chtype lne[WARNBOXH][WARNBOXW];
-
-   /* Default */
-   attrset(A_STANDOUT|COLOR_PAIR(0));
-   ln = strlen(s);
-   /* Halfway across screen */
-   lx = (COLS-ln)/2;
-   /* Store contents of screen */
-   for(i=0; i<WARNBOXH; i++){
-      mvinchnstr(i, lx, lne[i], ln);
-   }
-   /* Draw lines */
-   mvhline( 0, lx, 0, ln);
-   mvhline( 2, lx, 0, ln);
-   mvprintw(1, lx, s);
-   refresh();
-   /* 4 Seconds */
-   Neill_NCURS_Delay(4000.0);
-   /* Restore contents of screen */
-   for(i=0; i<WARNBOXH; i++){
-      mvaddchnstr(i, lx, lne[i], ln);
-   }
-   refresh();
-
-
-}
-
-/* Get mouse / key events & set sw.finished if appropriate */
-void Neill_NCURS_Events(NCURS_Simplewin *sw)
-{
-   int ch;
-   /* Keep processing events until none queued */
-   while((ch = getch()) != ERR){
-      switch(ch){
-         /* Any mouse press */
-         case KEY_MOUSE:
-         /* ESC key pressed - why not defined in ncurses.h ? */
-         case KEY_ESC:
-         case 'q':
-         case 'Q':
-              sw->finished = TRUE;
-              break;
-      }
-   }
-}
-
-
-/*
-   Make sure that all characters in string c are displayed in foreground colour fg,
-   background colour bg, with additional style attrs (which may be or'd together)
-   Colours can include :
-   COLOR_BLACK, COLOR_RED, COLOR_GREEN,COLOR_YELLOW, COLOR_BLUE, COLOR_MAGENTA, COLOR_CYAN, COLOR_WHITE
-   Attributes can include (but many may not be implemented by your terminal):
-   A_ALTCHARSET, A_BOLD, A_DIM, A_INVIS, A_PROTECT, A_REVERSE, A_STANDOUT, A_UNDERLINE
-*/
-void Neill_NCURS_CharStyle(NCURS_Simplewin *sw, char *c, short fg, short bg, int attrs)
-{
-
-   int i;
-   /* See if fg/bg are already a defined pair */
-   short ef, eb;
-   short pr = NOPAIR;
-   for(i=1; i<=sw->pairsdefd; i++){
-      pair_content(i, &ef, &eb);
-      /* Found existing pair */
-      if(ef==fg && eb==bg){
-         pr = i;
-      }
-   }
-   /* No pair found */
-   if(pr == NOPAIR){
-      sw->pairsdefd++;
-      pr = sw->pairsdefd;
-      init_pair(pr, fg, bg);
-   }
-
-   for(i=0; c[i] > '\0'; i++){
-      /* A_BOLD | A_REVERSE | A_DIM | A_UNDERLINE etc. */
-      sw->attr[(int)c[i]] = attrs;
-      sw->pair[(int)c[i]] = pr;
-   }
-
-}
-
-void Neill_NCURS_Done(void)
-{
-   /* Should deal with return value ? */
-   endwin();
-}
-
-void Neill_NCURS_Init(NCURS_Simplewin *sw)
-{
-
-   int i;
-   /* Global var `stdscr` is assigned by the call to initscr(), nasty ;-)
-      Even manual says no point in keeping return value, hence cast */
-   (void)initscr();
-   clear();
-   start_color();	
-   if(has_colors() == FALSE){
-        endwin();
-	fprintf(stderr, "Your terminal does not support colour\n");
-	exit(1);
-   }
-   sw->pairsdefd = 0;
-   /* All Characters default colour */
-   for(i=0 ;i<256; i++){
-      sw->pair[i] = 0;
-      sw->attr[i] = A_NORMAL;
-   }
-   cbreak();
-   nodelay(stdscr,TRUE);
-   noecho();
-   curs_set(FALSE);
-   sw->finished = FALSE;
-   /* Capture all mouse events */
-   mousemask(ALL_MOUSE_EVENTS, NULL);
-   /* Flush key presses on CTRL-C / Break etc. */
-   intrflush(NULL, TRUE);
-
-}
-
-/* a : Pointer to first character in 1D or 2D array
-   width, height of array to be displayed
-*/
-void Neill_NCURS_PrintArray(char *a, int width, int height, NCURS_Simplewin *sw)
-{
-   Neill_NCURS_PrintSubArray(a, width, height, width, sw);
-}
-
-/* Stride : When displaying a subpart of an array the displayed width might be
-   different from the true array size.*/
-void Neill_NCURS_PrintSubArray(char *a, int width, int height, int stride, NCURS_Simplewin *sw)
-{
-
-   int i, j;
-   static char *preva = NULL;
-   /* No colour pair yet */
-   short cp = NOPAIR;
-   /* No Attr yet */
-   unsigned long ap = A_NORMAL;
-   int termx, termy;
-   /* Macro not function, no pointers required. */
-   getmaxyx(stdscr, termy, termx);
-   if(width > termx || height > termy){
-      /* Don't repeat same warning for same array.Nasty. */
-      if(preva != a){
-         char str[256];
-         sprintf(str, "Terminal (%d,%d) too small for array (%d %d)", termx, termy, width, height); 
-         Neill_NCURS_Warning(str);
-         preva = a;
-      }
-   }
-   clear();
-   for(j=0; j<height; j++){
-      move(j,0);
-      for(i=0; i<width; i++){
-         int c = a[j*stride+i];
-         /* This colour/attribute different from last */
-         if((sw->pair[c] != cp) || (sw->attr[c] != ap)){
-            cp = sw->pair[c];
-            ap = sw->attr[c];
-            attrset(ap | COLOR_PAIR(cp));
-         }
-         addch(c);
-      }
-   }
-   refresh();
-
-}
Index: ../chap 4/4.1/4.1.c
===================================================================
--- ../chap 4/4.1/4.1.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/4.1.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,72 +0,0 @@
-#Life 1.06
-2 1
-2 2
-2 3
-#include <stdio.h>
-#include <stdlib.h>
-#define ROW 90
-#define COL 150
-
-void test();
-int cntneighbours(int rows, int columns,char grid[ROW][COL]);
-void generate(char oldvalue,char *newvalue,int m);
-int main()
-{
-    char grid1[ROW][COL];
-    char grid2[ROW][COL];
-    int x,y,m;
-
-    /*
-    for(y=0;y<ROW;y++){
-        for(x=0;x<COL;x++){
-            grid1[y][x]='0';
-        }
-    }
-    grid1[1][2]='1';
-    grid1[2][2]='1';
-    grid1[3][2]='1';
-    */
-    for (y=0;y<ROW;y++) {
-        for (x = 0; x < COL; x++) {
-            m=cntneighbours(y,x,grid1);
-            generate(grid1[y][x],&grid2[y][x],m);
-            printf("%c",grid2[y][x]);                /* print out the next board */
-        }
-        printf("\n");
-    }
-    return 0;
-}
-
-
-/* locate to a single cell, count neighbour cells (pass premise: in boundary) if they are '1'*/
-int cntneighbours(int rows, int columns,char grid[ROW][COL])
-{
-    int i,j,d,cnt=0;
-    int directions[8][2]= {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
-    for (d = 0; d < 8; d++) {
-        i = rows + directions[d][0];
-        j = columns + directions[d][1];
-        if (i >= 0 && i < ROW && j >= 0 && j < COL && grid[i][j] == '1') {
-            cnt++;
-        }
-    }
-    return cnt;
-}
-
-
-/* According to the number of neighbour trees, judge how the board will change next */
-void generate(char oldvalue,char *newvalue,int m)
-{
-    if (oldvalue=='1' && (m==2 || m==3)){
-        *newvalue='1';
-    }
-    else if(oldvalue=='1' &&(m<2 || m>3)){
-        *newvalue='0';
-    }
-    else if(oldvalue=='0' && m==3){
-        *newvalue='1';
-    }
-    else{
-        *newvalue='0';
-    }
-}
Index: ../chap 4/4.1/gosperglidergun_106.lif
===================================================================
--- ../chap 4/4.1/gosperglidergun_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/gosperglidergun_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,37 +0,0 @@
-#Life 1.06
-6 -4
-4 -3
-6 -3
--6 -2
--5 -2
-2 -2
-3 -2
-16 -2
-17 -2
--7 -1
--3 -1
-2 -1
-3 -1
-16 -1
-17 -1
--18 0
--17 0
--8 0
--2 0
-2 0
-3 0
--18 1
--17 1
--8 1
--4 1
--2 1
--1 1
-4 1
-6 1
--8 2
--2 2
-6 2
--7 3
--3 3
--6 4
--5 4
Index: ../chap9/3nd Hashing/notes/testassoc.c
===================================================================
--- ../chap9/3nd Hashing/notes/testassoc.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap9/3nd Hashing/notes/testassoc.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,100 +0,0 @@
-#include "notes/Notes-specific.h"
-#include "assoc.h"
-
-/*即使用unsigned long 也会size flaky?*/
-
-#define WORDS 370119
-#define NUMRANGE 100000
-
-char* strduprev(char* str);
-
-int main(void)
-{
-
-    static char strs[WORDS][50]={{0}};
-    FILE *fp;
-    char* tstr;
-    void *p;
-    unsigned int lngst;
-    unsigned int j;
-    assoc* a;
-    static int i[WORDS];
-
-    a = assoc_init(0);/* 传入0创建装字符串的表,返回指向表的指针assoc* a。sizeof key是0 因为【字符串】当key其size是0（而不是int、double等需要传递size的）
-                       * 字符串仅当需要strcpy strcmp时需要考虑size*/
-    fp = nfopen("../../Data/Words/eng_370k_shuffle.txt", "rt");
-    for(j=0; j<WORDS; j++){
-        assert(assoc_count(a)==j);/*返回哈希表中的个数，检验从0开始，检验上次是否插入成功*/
-        i[j] = j;/* i[j]逐个词存储索引--数据的伴随数 */
-        if(fscanf(fp, "%s", strs[j])!=1){/*逐个词，把字符串数据存到二维数组 str中。*/
-            on_error("Failed to scan in a word?");
-        }
-        assoc_insert(&a, strs[j], &i[j]);   /* 这里的key是字符串（所以开头传入0），data是"哪个单词"即"行数"！我们的函数所建哈希表只存指针，不存具体数值（存在其他地方）。 */
-    }                                       /* 哈希函数只针对key (这里是字符串，也就是单词)被哈希散列到表中去。*/
-
-    /*传a的地址--如realloc等需要resize table, 需要UPDATE a的地址，因此insert这里的a为 p2p*/
-    fclose(fp);
-
-    /*
-       What's the longest word that is still spelled
-       correctly when reversed, but is not a palindrome回文 ?
-    */
-    lngst = 0;
-    for(j=0; j<WORDS; j++){
-        /* Longest */
-        /* 举例：loops->spool */
-        if(strlen(strs[j]) > lngst){
-            tstr = strduprev(strs[j]);/*逐个字符复制，并颠倒顺序得到新字符串tsrt*/
-            /* Not a palindrome */
-            if(strcmp(tstr, strs[j])){/*排除回文*/
-                /* Spelled correctly */
-                if((p = assoc_lookup(a, tstr))!=NULL){/* key就是单词自己，数据是行号！在字典中查找tsrt在不在，如果在就是单词。如果找得到返回地址，找不到返回NULL*/
-                    lngst = strlen(tstr);/* 如果一切正常，记录最长的字符串的字符长度*/
-                    printf("%s <-> %s = %d (%d in the file)\n", tstr, strs[j], lngst, *(int*)p);/*用强制类型转换把data输出成整数*/
-                }
-            }
-            free(tstr);
-        }
-    }
-    assoc_free(a);/*结束哈希表，释放结构体*/
-
-    /*
-       Lets choose NUMRANGE numbers at random between 0 - (NUMRANGE-1)
-       and hash them.  Then assoc_count() tells us how many are unique
-    */
-    /*0 到99999数字*/
-    srand(time(NULL));
-    a = assoc_init(sizeof(int));/*创建哈希表。用户传入int的size大小，因为我们要用到的关键词是int型的。*/
-    for(j=0; j<NUMRANGE; j++){
-        i[j] = rand()%NUMRANGE;/*创建100000个篮子，每个篮子的球数量随机，从0到99999个*/
-        assoc_insert(&a, &i[j], NULL);/*这里i[j]是指向key的指针，也就是说可以在函数中修改哈希表的key，NULL是指向data的指针*/
-    }
-    printf("%d unique numbers out of %d\n", assoc_count(a), j);/*count函数计算成功hash的个数。*/
-                                                    /* 会出现几个篮子个数（key）相同的情况，但对于哈希函数来说，相同的key不会再次hash，因此不会再插入这个KEY,但会更新里面的数据*/
-
-    assoc_free(a);
-
-    return 0;
-}
-
-/* Make a copy, reversed */
-char* strduprev(char* str)
-{
-    int i, j;
-    char* t;
-    j = strlen(str);
-    t = ncalloc(j+1, 1); /* Add null char */
-    strcpy(t, str);
-    for(i=0, j--; i<j; i++,j--){
-        /* Swap using bit-twiddling */
-        t[i] ^= t[j];
-        t[j] ^= t[i];
-        t[i] ^= t[j];
-    }
-    return t;
-}
-
-/* 在自己的.c函数中可以进行测试但必须正确运行  不影响其他未知的测试 不需要写main */
-/* void pointer存储这些数据  每次hash或查找  key和数据是pair对应的 array太小需要调整尺寸 */
-/* 可能需要rehash 要把旧指针中的数据存到新的指针中  recopy..  */
-/* 拓展需要至少2个哈希函数。 */
\ No newline at end of file
Index: ../chap9/3nd Hashing/Cuckoo/cuckoo.c
===================================================================
--- ../chap9/3nd Hashing/Cuckoo/cuckoo.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap9/3nd Hashing/Cuckoo/cuckoo.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,182 +0,0 @@
-#include "specific.h"
-#include "../assoc.h"
-#include <math.h>
-/* Seed for BKDR Hash, can be 31 131 1313 13131 131313 etc.. */
-#define SEED 131
-#define LOAD_FACTOR 0.7
-typedef enum bool{false,true} bool;
-
-unsigned int Hash1(assoc* a, void* key);
-unsigned int Hash2(assoc* a, void* key);
-unsigned int Rehash_linear(assoc* a, unsigned int index);
-bool key_isSame(assoc* a, void* key, unsigned int lable, unsigned int index);
-assoc* assoc_realloc(assoc* old);
-
-assoc* assoc_init(int keysize)
-{
-    assoc* a;
-    if(keysize<0){
-        on_error("Invalid key size");
-    }
-    a = (assoc*) ncalloc(sizeof(assoc), 1);
-    a->hashTable[0] = (dataframe*) ncalloc(sizeof(dataframe), FIXEDSIZE);
-    a->hashTable[1] = (dataframe*) ncalloc(sizeof(dataframe), FIXEDSIZE);
-    a->size[0] = a->size[1] =0;
-    a->capacity = FIXEDSIZE;
-    a->keySize = keysize;
-    return a;
-}
-
-void assoc_insert(assoc** a, void* key, void* data)
-{
-    unsigned int index, lable, threshold;
-    static unsigned int cntColl = 0;
-    void *oldKey, *oldData;
-
-    if(*a == NULL || key == NULL){
-        return;
-    }
-
-    /* Resize & Rehash when table is too small */
-    threshold = log((*a)->capacity) / log(2);   /* 可能出错--需要转换成int型 */
-    if( cntColl >= threshold || (*a)->size[lable] >= (*a)->capacity){
-        *a = assoc_realloc(*a);
-        cntColl=0;
-    }
-
-    /* To bounce between hashTable t0 and t1 */
-    lable = cntColl % NUM_HASHTABLE;
-    index = (!lable) ? Hash1(*a,key) : Hash2(*a,key);
-    /* Cell of t0 is empty, do the insertion */
-    if((*a)->hashTable[lable][index].key == NULL) {
-        (*a)->hashTable[lable][index].key = key;
-        (*a)->hashTable[lable][index].data = data;
-        (*a)->size[lable] = (*a)->size[lable] + 1;
-    }
-    else{/* Cell of t0 is occupied */
-            /* Same key existed, update data only */
-        if (key_isSame(*a, key, lable, index)){
-            (*a)->hashTable[lable][index].data = data;
-            return;
-        }
-        else{
-            /* Collision, kick off the existed key */
-            cntColl++;
-            oldKey = (*a)->hashTable[lable][index].key;
-            oldData = (*a)->hashTable[lable][index].data;
-            /*再插入insert--与空格时一样的插入方法，可以包成小函数。*/
-            (*a)->hashTable[lable][index].key = key;
-            (*a)->hashTable[lable][index].key = data;
-            /* Rehash the kicked key */
-            assoc_insert(a,oldKey,oldData);
-            cntColl=0;
-        }
-    }
-}
-
-unsigned int assoc_count(assoc* a)
-{
-    if(a==NULL){
-        return 0;
-    }
-    return a->size[0] + a->size[1];
-}
-
-void* assoc_lookup(assoc* a, void* key)
-{
-    unsigned int index,i;
-    if(key == NULL){
-        printf("Invalid key\n");
-        return NULL;
-    }
-    if(assoc_count(a)==0){
-        printf("Empty dictionary\n");
-        return NULL;
-    }
-    if(a->hashTable[i][index].key != NULL){
-        for(i = 0; i < NUM_HASHTABLE; i++) {
-            index = (!i) ? Hash1(a,key) : Hash2(a,key);
-            if (key_isSame(a, key, i, index)) {
-                return a->hashTable[i][index].data;
-            }
-        }
-    }
-    return NULL;
-}
-
-void assoc_free(assoc* a)
-{
-    int i;
-    for(i = 0; i < NUM_HASHTABLE; i++) {
-        free(a->hashTable[i]);
-    }
-    free(a);
-}
-
-/*---------------Private Function---------------*/
-/* BKDR Hash function */
-unsigned int Hash1(assoc* a, void* key)
-{
-    unsigned int hash = 0;
-    char* p=key;
-    int i=0;
-    while( i++ < a->keySize || (a->keySize==0 && *p!='\0')){
-        hash = hash * SEED + (*p++);
-    }
-    return (hash % a->capacity);
-}
-
-/* AP Hash function  */
-unsigned int Hash2(assoc* a, void* key)
-{
-    unsigned int hash = 0;
-    char* p=key;
-    int i=0;
-    while( i++ < a->keySize || (a->keySize==0 && *p!='\0')){
-        if ((i & 1) == 0)
-        {
-            hash ^= ((hash << 7) ^ (*p++) ^ (hash >> 3));
-        }
-        else
-        {
-            hash ^= (~((hash << 11) ^ (*p++) ^ (hash >> 5)));
-        }
-    }
-    return (hash % a->capacity);
-}
-
-bool key_isSame(assoc* a, void* key, unsigned int lable, unsigned int index)
-{
-    if(a->keySize == 0){
-        if(!strcmp(a->hashTable[lable][index].key, key)){
-            return true;
-        }
-    }else{
-        if(!memcmp(a->hashTable[lable][index].key, key, a->keySize)){
-            return true;
-        }
-    }
-    return false;
-}
-
-assoc* assoc_realloc(assoc* old)
-{
-    unsigned int i;
-    assoc* new;
-    new = (assoc*) ncalloc(sizeof(assoc), 1);
-    new->hashTable[0]= (dataframe*) ncalloc(sizeof(dataframe), old->capacity * SCALEFACTOR);
-    new->hashTable[1]= (dataframe*) ncalloc(sizeof(dataframe), old->capacity * SCALEFACTOR);
-    new->size[0] = new->size[1] = 0;
-    new->keySize = old->keySize;
-    new->capacity = old->capacity * SCALEFACTOR;
-    /* Rehash */
-    for (j = 0; j < NUM_HASHTABLE; j++) {
-        for(i = 0; i < old->capacity; i++) {
-            if (assoc_count(new) < assoc_count(old)) {
-                assoc_insert(&new, old->hashTable[j][i].key, old->hashTable[j][i].data);
-            }
-        }
-    }
-    assoc_free(old);
-    return new;
-}
Index: ../chap 4/4.1/glider_106.lif
===================================================================
--- ../chap 4/4.1/glider_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/glider_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,6 +0,0 @@
-#Life 1.06
-0 -1
-1 0
--1 1
-0 1
-1 1
Index: ../chap9/3nd Hashing/test2.c
===================================================================
--- ../chap9/3nd Hashing/test2.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap9/3nd Hashing/test2.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,4 +0,0 @@
-//
-// Created by Karine Liang on 2020/12/16.
-//
-
Index: ../chap 4/4.1/bigglider_106.lif
===================================================================
--- ../chap 4/4.1/bigglider_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/bigglider_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,69 +0,0 @@
-#Life 1.06
--6 -9
--5 -9
--4 -9
--6 -8
--3 -8
--2 -8
--1 -8
--5 -7
--3 -7
--9 -6
--8 -6
-0 -6
--9 -5
--7 -5
--2 -5
-1 -5
--9 -4
-0 -4
-1 -4
--8 -3
--7 -3
--8 -2
--5 -2
-1 -2
-3 -2
-4 -2
--8 -1
-2 -1
-3 -1
-5 -1
--6 0
--4 0
-3 0
-4 0
-7 0
--5 1
--4 1
--2 1
-3 1
-4 1
-8 1
--1 2
-7 2
--2 3
--1 3
-0 3
-1 3
-5 3
-7 3
--2 4
-0 4
-1 4
-5 4
-6 4
-7 4
-8 4
--1 5
-3 5
-4 5
-6 5
-4 6
-5 6
-0 7
-2 7
-3 7
-4 7
-1 8
-4 8
Index: ../CA-template.s
===================================================================
--- ../CA-template.s	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../CA-template.s	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,7 +0,0 @@
-.section .text
-.align    2
-.global   _start
-_start:
-@ your code goes here
-@ lines starting with @ are comments
-
Index: ../1st assignment forest fire/forest_ex.c
===================================================================
--- ../1st assignment forest fire/forest_ex.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../1st assignment forest fire/forest_ex.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,391 +0,0 @@
-#include <stdio.h>
-#include <time.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <string.h>
-#include "neillsimplescreen.h"
-
-#define G 250
-#define L (G*10)
-#define ROWS 30
-#define COLS 80
-#define GENERATIONS 1000
-#define MARGIN4TEST 100
-#define OUTPUTSPEED 0.04
-
-enum state {empty, tree, fire};
-typedef enum state state;
-enum bool {false, true};
-typedef enum bool bool;
-
-/* Testing all other functions */
-void test(void);
-/* For testing printed arrays */
-void stringify_test(state *grid, char *s, int rows, int cols);
-/* Initialise the grid to empty */
-void initialise(state grid[ROWS][COLS]);
-/* Prints the grid in area 80 wide and 30 high */
-void print_gen(state grid[ROWS][COLS]);
-/* Converts states to chars for printing */
-char stringify(state cell);
-/* Colourise tree and fire output */
-void colourise(char c);
-/* Process next generation of grid */
-void processgrid(state grid[ROWS][COLS], state nextgrid[ROWS][COLS]);
-/* Process next generation of each cell */
-state forestfire(state grid[ROWS][COLS], int x, int y);
-/* Processes cells which are trees */
-state rules4tree(state grid[ROWS][COLS], int y, int x);
-/* Returns true if neighbouring cells are on fire */
-bool isneighbour_onfire(state grid[ROWS][COLS], int y, int x);
-/* Ensures array indexes are within bounds of the grid */
-state safe(state grid[ROWS][COLS], int y, int x);
-/* Returns a tree for 1 in G times */
-state spontgrowth(void);
-/* Returns true 1 time in L */
-bool islightning(void);
-/* Creates copy of existing grid, ready for next loop */
-void copyarray(state copyfrom[ROWS][COLS], state copy2[ROWS][COLS]);
-
-
-int main(void)
-{
-   int i;
-   state grid[ROWS][COLS];
-   state next_gen[ROWS][COLS];
-   test();
-   srand(time(NULL));
-   neillclrscrn();
-   initialise(grid);
-   for(i=0; i<GENERATIONS; i++) {
-      neillcursorhome();
-      print_gen(grid);
-      processgrid(grid, next_gen);
-      copyarray(next_gen, grid);
-      neillbusywait(OUTPUTSPEED);
-   }
-   neillfgcol(white);
-   return 0;
-}
-
-void initialise(state grid[ROWS][COLS])
-{
-   int i, j;
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         grid[j][i] = empty;
-      }
-   }
-}
-
-void processgrid(state grid[ROWS][COLS], state nextgrid[ROWS][COLS])
-{
-   int i, j;
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         nextgrid[j][i] = forestfire(grid, j, i);
-      }
-   }
-}
-
-state forestfire(state grid[ROWS][COLS], int y, int x)
-{
-   switch(grid[y][x]) {
-      case fire  :
-         return empty;
-      case tree  :
-         return rules4tree(grid, y, x);
-      case empty :
-         return spontgrowth();
-      default    :
-         return empty;
-   }
-}
-
-state rules4tree(state grid[ROWS][COLS], int y, int x)
-{
-   if(isneighbour_onfire(grid, y, x) == true) {
-      return fire;
-   }
-   if(islightning() == true) {
-      return fire;
-   }
-   return tree;
-}
-
-bool isneighbour_onfire(state grid[ROWS][COLS], int y, int x)
-{
-   state a;
-   int i, j;
-   /* Check 8-neighbourhood for fire */
-   for(j=-1; j<=1; j++) {
-      for(i=-1; i<=1; i++) {
-         a = safe(grid, y+j, x+i);
-         if(a == fire) {
-            return true;
-         }
-      }
-   }
-   return false;
-}
-
-state safe(state grid[ROWS][COLS], int y, int x)
-{
-   /* when index out of bounds, return empty */
-   if((y < 0) || (y >= ROWS) || (x < 0) || (x >= COLS)) {
-      return empty;
-   }
-   return grid[y][x];
-}
-
-bool islightning(void)
-{
-   /* lightning strikes 1 time in L */
-   if((rand() % L) == 1) {
-      return true;
-   }
-   return false;
-}
-
-state spontgrowth(void)
-{
-   /* spontaneous growth 1 time in G */
-   if((rand() % G) == 1) {
-      return tree;
-   }
-   return empty;
-}
-
-void print_gen(state grid[ROWS][COLS])
-{
-   int i, j;
-   char c;
-   for(j=0; j<ROWS; j++) {
-      if(j != 0) {
-         printf("\n");
-      }
-      for(i=0; i<COLS; i++) {
-         c = stringify(grid[j][i]);
-         colourise(c);
-         printf("%c", c);
-      }
-   }
-}
-
-char stringify(state cell)
-{
-   switch(cell) {
-      case tree :
-         return '@';
-      case fire :
-         return '*';
-      case empty :
-         return ' ';
-      default :
-         return ' ';
-   }
-}
-
-void colourise(char c)
-{
-   if(c == '@') {
-      neillfgcol(green);
-   }
-   if(c == '*') {
-      neillfgcol(red);
-   }
-}
-
-void copyarray(state copyfrom[ROWS][COLS], state copy2[ROWS][COLS])
-{
-   int j, i;
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         copy2[j][i] = copyfrom[j][i];
-      }
-   }
-}
-
-void test(void)
-{
-   int i, j;
-   int lightning_cnt, not_lightning;
-   int spont_growth, not_growth;
-   state new_state1, new_state2, new_state3;
-   state s1[ROWS][COLS]; /* For testing empty cells */
-   /* Non-empty grid to test initialisation */
-   state s2[ROWS][COLS] = {{fire, fire, fire},\
-                           {fire, fire, fire}};
-   state s3[ROWS][COLS]; /* For testing trees */
-   state s4[ROWS][COLS]; /* For testing tree neighbourhood rule */
-   /* For testing forestfire */
-   state s5[ROWS][COLS] = {{empty, fire, tree},\
-                           {empty, fire, tree},\
-                           {empty, tree, tree}};
-   state s6[ROWS][COLS]; /* For testing fire */
-   /* For testing printing */
-   state s7[3][3] = {{fire, empty, tree},\
-                     {fire, empty, tree},\
-                     {fire, empty, tree}};
-   /* For testing processgrid */
-   state s8[ROWS][COLS];
-   state s9[ROWS][COLS];
-   state s10[ROWS][COLS];
-   state s11[ROWS][COLS];
-   state s12[ROWS][COLS];
-   state s13[ROWS][COLS];
-   /* For testing copyarray */
-   state s14[ROWS][COLS];
-   state s15[ROWS][COLS];
-   state s16[ROWS][COLS];
-   char ns1[10]; /* For testing stringify */
-   char ns2[10]; /* For testing stringify */
-
-   /* Test initialisiation */
-   initialise(s1);
-   initialise(s2);
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         assert(s1[j][i]==empty);
-         assert(s2[j][i]==empty);
-      }
-   }
-   /* Test safe method */
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         s3[j][i] = tree;
-         /* index within array bounds and should return tree */
-         assert(safe(s3, j,      i     )==tree);
-         /* indexes out of bounds, should return empty */
-         assert(safe(s3, j+ROWS, i+COLS)==empty);
-      }
-   }
-   /* Test isneighbour_onfire */
-   /* Creating a single fire sourrounded by trees */
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         s4[j][i] = tree;
-      }
-   }
-   s4[1][1] = fire;
-   assert(isneighbour_onfire(s4, 0, 0)==true);
-   assert(isneighbour_onfire(s4, 0, 1)==true);
-   assert(isneighbour_onfire(s4, 0, 2)==true);
-   assert(isneighbour_onfire(s4, 1, 0)==true);
-   assert(isneighbour_onfire(s4, 1, 2)==true);
-   assert(isneighbour_onfire(s4, 2, 0)==true);
-   assert(isneighbour_onfire(s4, 2, 1)==true);
-   assert(isneighbour_onfire(s4, 2, 2)==true);
-   assert(isneighbour_onfire(s4, 3, 0)==false);
-   assert(isneighbour_onfire(s4, 1, 3)==false);
-   assert(isneighbour_onfire(s4, 2, 3)==false);
-
-   /* Test rules4tree method */
-   /* Ensure trees turn to fire on next generation */
-   assert(rules4tree(s4, 0, 0)==fire);
-   assert(rules4tree(s4, 0, 1)==fire);
-   assert(rules4tree(s4, 0, 2)==fire);
-   assert(rules4tree(s4, 1, 0)==fire);
-   assert(rules4tree(s4, 1, 2)==fire);
-   assert(rules4tree(s4, 2, 0)==fire);
-   assert(rules4tree(s4, 2, 1)==fire);
-   assert(rules4tree(s4, 2, 2)==fire);
-   s4[1][1] = tree;
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         new_state1 = rules4tree(s4, j, i);
-         assert((new_state1==tree) || (new_state1==fire));
-      }
-   }
-   /* Test lightning strike */
-   lightning_cnt = 0; not_lightning = 0;
-   for(i=0; i<L*MARGIN4TEST; i++) {
-      if(islightning() == true) {
-         lightning_cnt++;
-      }
-      else {
-         not_lightning++;
-      }
-   }
-   assert(lightning_cnt>0);
-   assert(not_lightning>0); assert(not_lightning<(L*MARGIN4TEST));
-
-   /* Test spontaneous growth */
-   spont_growth = 0; not_growth = 0;
-   for(i=0; i<G*MARGIN4TEST; i++) {
-      if(spontgrowth()==tree) {
-         spont_growth++;
-      }
-      else {
-         not_growth++;
-      }
-   }
-   assert(spont_growth>0);
-   assert(not_growth>0); assert(not_growth<(G*MARGIN4TEST));
-
-   /* Test forestfire */
-   assert(forestfire(s5,0,2)==fire); /* tree -> fire (8-neighbourhood) */
-   initialise(s1);
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         s6[j][i] = fire;
-         /* fire -> empty */
-         new_state1 = forestfire(s6,j,i);
-         assert(new_state1==empty);
-         /* Tree -> tree || fire */
-         new_state2 = forestfire(s3,j,i);
-         assert((new_state2==tree)  || (new_state2==fire));
-         /* Empty -> tree || empty */
-         new_state3 = forestfire(s1,j,i);
-         assert((new_state3==empty) || (new_state3==tree));
-      }
-   }
-
-   /* Test stringify */
-   assert(stringify(empty)==' ');
-   assert(stringify(fire)=='*');
-   assert(stringify(tree)=='@');
-   stringify_test(&s1[0][0], &ns1[0], 3, 3);
-   stringify_test(&s7[0][0], &ns2[0], 3, 3);
-   assert(strcmp(ns1, "         ")==0);
-   assert(strcmp(ns2, "* @* @* @")==0);
-
-   /* Test processgrid */
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         (s8 [j][i]=fire);
-         (s9 [j][i]=empty);
-         (s10[j][i]=tree);
-      }
-   }
-   processgrid(s8, s11);
-   processgrid(s9, s12);
-   processgrid(s10,s13);
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         assert( s11[j][i]==empty);
-         assert((s12[j][i]==empty) || (s12[j][i]==tree));
-         assert((s13[j][i]==tree)  || (s13[j][i]==fire));
-      }
-   }
-   /* Test copy array */
-   copyarray(s8, s14);
-   copyarray(s9, s15);
-   copyarray(s10, s16);
-   for(j=0; j<ROWS; j++) {
-      for(i=0; i<COLS; i++) {
-         assert(s14[j][i]==fire);
-         assert(s15[j][i]==empty);
-         assert(s16[j][i]==tree);
-      }
-   }
-}
-
-void stringify_test(state *grid, char *s, int rows, int cols)
-{
-   int i;
-   for(i=0; i<rows*cols; i++) {
-      s[i] = stringify(grid[i]);
-   }
-   s[i] = '\0';
-}
Index: ../chap9/3nd Hashing/Realloc/realloc.c
===================================================================
--- ../chap9/3nd Hashing/Realloc/realloc.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap9/3nd Hashing/Realloc/realloc.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,151 +0,0 @@
-#include "specific.h"
-#include "../assoc.h"
-
-/* Seed for BKDR Hash, can be 31 131 1313 13131 131313 etc.. */
-#define SEED 131
-
-unsigned int Hash1(assoc* a, void* key);
-/*unsigned int Hash2(assoc* a, void* key);*/
-unsigned int DetectedLine(assoc* a, unsigned int index)
-
-assoc* assoc_init(int keysize)
-{
-    if(keysize<0){
-        on_error("Invalid keysize");
-    }
-    assoc* a = (assoc*) ncalloc(sizeof(assoc), 1);
-    a->hashTable = (dataframe*) ncalloc(sizeof(dataframe), FIXEDSIZE);
-    a->size = 0;
-    a->capacity = FIXEDSIZE;
-    a->keySize = keysize;
-    return a;
-}
-
-void assoc_insert(assoc** a, void* key, void* data)
-{
-    assoc* new;
-    assoc* old;
-    unsigned int index;
-    if(*a == NULL || key == NULL){
-        return;
-    }
-
-    index = Hash1(*a,key);
-
-    /* Cell occupied */
-    while((*a)->hashTable[index]->key != NULL){
-        /* Key repeats */
-        if ((!(*a)->keySize  &&  !strcmp(key,(*a)->hashTable[index]->key)) ||
-            ( (*a)->keySize  &&  !memcmp(key,(*a)->hashTable[index]->key,(*a)->keySize))){
-            (*a)->hashTable[index]->data = data;
-            return;
-        }else{
-        /* Collision */
-            index = DetectedLine(*a,index);
-        }
-    }
-
-    /* Cell empty */
-    if((*a)->keySize==0){
-        strcpy((*a)->hashTable[index]->key, key));
-    }else{
-        memcpy((*a)->hashTable[index]->key, key, (*a)->keySize));
-    }
-    (*a)->hashTable[index]->data = data;
-    (*a)->size = (*a)->size + 1;
-
-    /* Once hashTable is too small, Resize it */
-    old = *a;
-    if((*a)->size >= (*a)->capacity) {
-        new = (assoc*) ncalloc(sizeof(assoc), 1);
-        new->hashTable = (dataframe*) ncalloc(sizeof(dataframe), old->capacity * SCALEFACTOR);
-        new->size = 0;
-        new->keySize = old->keySize;
-        new->capacity = old->capacity * SCALEFACTOR;
-
-        /* Rehash */
-        for(i = 0; i < old->capacity; i++){
-            if(new->size < old->size) {
-                assoc_insert(&new,old->hashTable[i]->key,old->hashTable[i]->data);
-            }else{
-                /* To End the loop once all the keys are rehashed & inserted */
-                i = old->capacity;
-            }
-        }
-        *a = new;
-        free(old->hashTable);
-        free(old);
-    }
-}
-
-unsigned int assoc_count(assoc* a)
-{
-    if(a){
-        return a->size;
-    }
-}
-
-void* assoc_lookup(assoc* a, void* key)
-{
-    unsigned int index;
-    if(a == NULL){
-        return;
-    }
-    if(key == NULL){
-        printf("Invalid key\n");
-        return;
-    }
-    if(assoc_count(a)==0){
-        printf("Empty dictionary\n");
-        return;
-    }
-
-    index = Hash1(*a,key);
-    while(a->hashTable[index]->key != NULL){
-        if((a->keySize==0 && strcmp(key, a->hashTable[index]->key)==0) ||
-           (a->keySize!=0 && memcmp(key, a->hashTable[index]->key, a->keySize)==0)) {
-            return a->hashTable[index]->data;
-        }else{
-            index = DetectedLine(a,index);
-        }
-    }
-    return NULL;
-}
-
-void assoc_free(assoc* a)
-{
-    free(a->hashTable);
-    free(a);
-}
-
-/*---------------Private Function---------------*/
-/* Use BKDR hash */
-unsigned int Hash1(assoc* a, void* key)
-{
-    unsigned int hash = 0;
-    char* p=key;
-    int i=0;
-    while( i++ < a->keySize || (a->keySize==0 && *p!='\0')){
-        hash = hash * SEED + (*p++);
-    }
-    return (hash % a->capacity);
-}
-
-/* Use Linear probing */
-unsigned int DetectedLine(assoc* a, unsigned int index)
-{
-    index += 1;
-    return index % a->capacity;
-}
-
-
-
-/*
-unsigned int Hash2(assoc* a, void* key)
-{
-    int decrement = 1;
-    unsigned int hash = 0;
-
-    return ;
-}
-*/
\ No newline at end of file
Index: ../chap9/3nd Hashing/test3.c
===================================================================
--- ../chap9/3nd Hashing/test3.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap9/3nd Hashing/test3.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,52 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#define SEED 131
-unsigned int Hash1(assoc* a, void* key);
-unsigned int Hash2(assoc* a, void* key);
-
-int main()
-{
-    void *key01,*key02,*key03;
-    float j = 11.05;
-    int i = 12;
-    char* str="abc";
-    key01 = &j;
-    key02 = &i;
-    key03 = str;
-    hash01 = BKDRHash;
-    hash02 = BKDRHash;
-    hash03 = BKDRHash;
-    printf("%d %d %d.\n",Hash1(key01,4,16),Hash1(key02,4,16),Hash1(key03,4,16));
-    printf("%d %d %d.\n",Hash2(key01,4,16),Hash2(key02,4,16),Hash2(key03,4,16));
-}
-
-unsigned int Hash1(void* key, int keySize, int size_hashArray)
-{
-    unsigned int hash = 0;
-    char* p=key;
-    int i=0;
-    while( i++ < keySize || (keySize==0 && *p!='\0')){
-        hash = hash * SEED + *(p++);
-    }
-    return hash % size_hashArray;
-}
-
-unsigned int Hash2(void* key, int keySize, int size_hashArray)
-{
-    unsigned int hash = 0;
-    int i;
-    for (i=0; i < keySize || *key; i++)
-    {
-        if ((i & 1) == 0)
-        {
-            hash ^= ((hash << 7) ^ (*key++) ^ (hash >> 3));
-        }
-        else
-        {
-            hash ^= (~((hash << 11) ^ (*key++) ^ (hash >> 5)));
-        }
-    }
-
-    return (hash % size_hashArray);
-}
-}
\ No newline at end of file
Index: ../chap 4/4.1/blinkerpuffer2_106.lif
===================================================================
--- ../chap 4/4.1/blinkerpuffer2_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/blinkerpuffer2_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,80 +0,0 @@
-#Life 1.06
-5 -12
-6 -12
-7 -12
-4 -11
-5 -11
-6 -11
-7 -11
-8 -11
-3 -10
-4 -10
-6 -10
-7 -10
-8 -10
-4 -9
-5 -9
-1 -6
-3 -6
--6 -5
-0 -5
-3 -5
--7 -4
--6 -4
--5 -4
--4 -4
--3 -4
-1 -4
-3 -4
--8 -3
--7 -3
--3 -3
--2 -3
-0 -3
-1 -3
--7 -2
-1 -2
--6 -1
--5 -1
--2 -1
-1 -1
-2 0
--6 1
--5 1
--2 1
-1 1
--7 2
-1 2
--8 3
--7 3
--3 3
--2 3
-0 3
-1 3
--7 4
--6 4
--5 4
--4 4
--3 4
-1 4
-3 4
--6 5
-0 5
-3 5
-1 6
-3 6
-4 9
-5 9
-3 10
-4 10
-6 10
-7 10
-8 10
-4 11
-5 11
-6 11
-7 11
-8 11
-5 12
-6 12
-7 12
Index: ../chap 4/4.1/neillncurses.h
===================================================================
--- ../chap 4/4.1/neillncurses.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/neillncurses.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,30 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <ncurses.h>
-
-#define KEY_ESC 27
-
-#define WARNBOXH 3
-#define WARNBOXW 1024
-
-#define NOPAIR -2
-
-struct NCURS_Simplewin {
-   bool finished;
-   unsigned long attr[256]; /* Atrributes for each character */
-   short pair[256]; /* Which Colour pair for each character */
-   unsigned short pairsdefd;
-};
-typedef struct NCURS_Simplewin NCURS_Simplewin;
-
-void Neill_NCURS_Delay(double ms);
-void Neill_NCURS_Warning(char *s);
-void Neill_NCURS_Events(NCURS_Simplewin *sw);
-void Neill_NCURS_CharStyle(NCURS_Simplewin *sw, char *c, short fg, short bg, int attrs);
-void Neill_NCURS_Done(void);
-void Neill_NCURS_Init(NCURS_Simplewin *sw);
-void Neill_NCURS_PrintArray(char *a, int width, int height, NCURS_Simplewin *sw);
-void Neill_NCURS_PrintSubArray(char *a, int width, int height, int stride, NCURS_Simplewin *sw);
-void Neill_NCURS_PrintLine(char *a, int width, int height,  NCURS_Simplewin *sw);
Index: ../chap 4/4.1/newgun2_106.lif
===================================================================
--- ../chap 4/4.1/newgun2_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/newgun2_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,96 +0,0 @@
-#Life 1.06
--2 -12
--1 -12
-24 -12
-25 -12
--2 -11
--1 -11
-24 -11
-25 -11
-16 -10
-17 -10
-15 -9
-18 -9
-16 -8
-17 -8
-11 -6
-12 -6
-13 -6
-11 -5
-13 -5
--16 -4
--15 -4
-11 -4
-12 -4
-13 -4
--16 -3
--15 -3
-11 -3
-12 -3
--17 -2
--14 -2
-10 -2
-11 -2
-12 -2
--17 -1
--14 -1
--12 -1
--11 -1
-10 -1
-12 -1
--17 0
--12 0
--11 0
-10 0
-11 0
-12 0
--15 1
--14 1
--12 1
--11 1
-6 2
-7 2
--4 3
--3 3
-5 3
-8 3
--4 4
--3 4
-6 4
-7 4
-24 5
-25 5
-24 6
-25 6
--21 8
--20 8
--1 8
--25 9
--24 9
--19 9
--18 9
--17 9
--16 9
--5 9
--4 9
--1 9
-0 9
-2 9
-3 9
-4 9
--25 10
--24 10
--21 10
--20 10
--18 10
--17 10
--16 10
--5 10
--4 10
-1 10
-2 10
-3 10
-4 10
--21 11
--1 11
-0 11
Index: ../stacks.c
===================================================================
--- ../stacks.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../stacks.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,4 +0,0 @@
-//
-// Created by Karine Liang on 2020/11/16.
-//
-
Index: ../chap 4/4.1/bigun_106.lif
===================================================================
--- ../chap 4/4.1/bigun_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap 4/4.1/bigun_106.lif	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
@@ -1,45 +0,0 @@
-#Life 1.06
--14 -7
--15 -6
--14 -6
--16 -5
--15 -5
--15 -4
--14 -4
--11 -4
--10 -4
-13 -3
-13 -2
-14 -2
-23 -2
-24 -2
-14 -1
-15 -1
-23 -1
-24 -1
--15 0
--14 0
--11 0
--10 0
-9 0
-10 0
-13 0
-14 0
--25 1
--24 1
--16 1
--15 1
--25 2
--24 2
--15 2
--14 2
--14 3
-9 4
-10 4
-13 4
-14 4
-14 5
-15 5
-13 6
-14 6
-13 7
Index: ../2nd/open.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2020/11/26.\n//\n\n
===================================================================
--- ../2nd/open.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../2nd/open.c	(date 1615245742174)
@@ -1,4 +1,66 @@
-//
-// Created by Karine Liang on 2020/11/26.
-//
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#define MAXCOLUMN 9
+#define MAXROW 9
+#define ERROR(PHRASE) {fprintf(stderr,"%s\n",PHRASE);exit(EXIT_FAILURE);}
+
+void readfile(const char* filename,char grid[MAXROW][MAXCOLUMN],int *row,int *column);
+int main(int argc, char const *argv[]){
+    char bookcase[MAXROW][MAXCOLUMN];
+    int row,column;
+    int i,j;
+    if(argc>=2){
+        readfile(argv[1],bookcase,&row,&column);
+    }
+    else{
+        ERROR("no input file?");
+    }
 
+    for(j=0;j<row;j++){
+        for(i=0;i<column;i++){
+            printf("%c ",bookcase[j][i]);
+        }
+        printf("\n");
+    }
+    return 0;
+}
+
+
+void readfile(const char* filename,char grid[MAXROW][MAXCOLUMN],int *row,int *column)
+{
+    FILE* file;
+    char str[10];
+    int y, x ;
+    file = fopen(filename, "r");
+    if (file == NULL) {
+        ERROR("file not found");
+    }
+/* get the first line */
+    if(fgets(str,10,file) != NULL){
+        if(sscanf(str,"%d%d",row,column) != 2){
+            ERROR("invalid head line");
+        }
+    }
+/* get the bookcase */
+    y = 0;
+    while(fgets(str,10,file) != NULL){
+        x = 0;
+        if (y >= *row) {
+            ERROR("incorrect row number. ");
+        }
+        while(x < *column){
+            if (str[x]!='.'&&!isalpha(str[x])) {
+                ERROR("invalid characters.");
+            }
+            if(isalpha(str[x])){
+                str[x]=toupper(str[x]);
+            }
+            grid[y][x] = str[x];
+            x ++;
+        }
+        y ++;
+    }
+    fclose(file);
+}
Index: ../chap9/3nd Hashing/assoc.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n   A Hash Table, storing void pointers to a key/data pair.\n   The user is responsible for keeping the data persistent\n   (i.e. pointing at objects that haven't been freed)\n   No copying of key/data is done.\n*/\n\n#include \"ADTs/General/general.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <time.h>\n#include <string.h>\n\n/*\n   Initialise the Associative array\n   keysize : number of bytes (or 0 => string)\n   This is important when comparing keys since\n   we'll need to use either memcmp(), strcmp()\n   有size后，对于实数我们可用 memcmp(),memcpy() or 对于字符串可用strcmp(),strcpy()了。\n*/\n/* 来自题目：用户需要自行传递所用key的size (e.g. sizeof(int))\n * 如果用的是strings, 就是传递特殊值0.\n * Q：key种类那么多，通过什么哈希函数转换？ ————A：将key当作一个有着n个字符（字节）的bag包袋. 哈希函数正适合处理字节.*/\nassoc* assoc_init(int keysize);\n\n/*\n   Insert key/data pair\n   - may cause resize, therefore 'a' might\n   be changed due to a realloc() etc.\n*/\nvoid assoc_insert(assoc** a, void* key, void* data);\n\n/*\n   Returns the number of key/data pairs\n   currently stored in the table\n*/\nunsigned int assoc_count(assoc* a);\n\n/* 查找时只需要return：返回一个指向数据的指针地址，不需要处理它，因此size不重要。\n   Returns a pointer to the data, given a key\n   NULL => not found\n*/\nvoid* assoc_lookup(assoc* a, void* key);\n\n/* No need to implement */\nvoid assoc_todot(assoc* a);\n\n/* Free up all allocated space from 'a' */\nvoid assoc_free(assoc* a);
===================================================================
--- ../chap9/3nd Hashing/assoc.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ Hashing/assoc.h	(date 1615245742446)
@@ -5,7 +5,7 @@
    No copying of key/data is done.
 */
 
-#include "ADTs/General/general.h"
+#include "../../ADTs/General/general.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -17,12 +17,8 @@
    Initialise the Associative array
    keysize : number of bytes (or 0 => string)
    This is important when comparing keys since
-   we'll need to use either memcmp(), strcmp()
-   有size后，对于实数我们可用 memcmp(),memcpy() or 对于字符串可用strcmp(),strcpy()了。
+   we'll need to use either memcmp() or strcmp()
 */
-/* 来自题目：用户需要自行传递所用key的size (e.g. sizeof(int))
- * 如果用的是strings, 就是传递特殊值0.
- * Q：key种类那么多，通过什么哈希函数转换？ ————A：将key当作一个有着n个字符（字节）的bag包袋. 哈希函数正适合处理字节.*/
 assoc* assoc_init(int keysize);
 
 /*
@@ -38,7 +34,7 @@
 */
 unsigned int assoc_count(assoc* a);
 
-/* 查找时只需要return：返回一个指向数据的指针地址，不需要处理它，因此size不重要。
+/*
    Returns a pointer to the data, given a key
    NULL => not found
 */
@@ -48,4 +44,4 @@
 void assoc_todot(assoc* a);
 
 /* Free up all allocated space from 'a' */
-void assoc_free(assoc* a);
\ No newline at end of file
+void assoc_free(assoc* a);
Index: ../2nd/Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#CFLAGS=-Wall -Wextra -pedantic -std=c90 -O3\nCFLAGS=-Wall -Wextra -pedantic -std=c90 -lm -fsanitize=address -fsanitize=undefined -g3\nCC=gcc\nLDLIBS=-lm\n
===================================================================
--- ../2nd/Makefile	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../2nd/Makefile	(date 1615245742178)
@@ -1,4 +1,7 @@
-#CFLAGS=-Wall -Wextra -pedantic -std=c90 -O3
 CFLAGS=-Wall -Wextra -pedantic -std=c90 -lm -fsanitize=address -fsanitize=undefined -g3
+#CFLAGS=-Wall -Wextra -pedantic -std=c90 -g3
+#valgrind --leak-check=full ./myexec
+#CFLAGS=-Wall -Wextra -pedantic -std=c90 -O3
 CC=gcc
+#CC=clang
 LDLIBS=-lm
Index: Hashing/testassoc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Hashing/testassoc.c	(date 1615245742438)
+++ Hashing/testassoc.c	(date 1615245742438)
@@ -0,0 +1,87 @@
+#include "specific.h"
+#include "assoc.h"
+
+#define WORDS 370119
+#define NUMRANGE 100000
+
+char* strduprev(char* str);
+
+int main(void)
+{
+
+    static char strs[WORDS][50]={{0}};
+    FILE *fp;
+    char* tstr;
+    void *p;
+    unsigned int lngst;
+    unsigned int j;
+    assoc* a;
+    static int i[WORDS];
+
+    a = assoc_init(0);
+    fp = nfopen("../../Data/Words/eng_370k_shuffle.txt", "rt");
+    for(j=0; j<WORDS; j++){
+        assert(assoc_count(a)==j);
+        i[j] = j;
+        if(fscanf(fp, "%s", strs[j])!=1){
+            on_error("Failed to scan in a word?");
+        }
+        assoc_insert(&a, strs[j], &i[j]);
+    }
+    fclose(fp);
+
+    /*
+       What's the longest word that is still spelled
+       correctly when reversed, but is not a palindrome ?
+    */
+    lngst = 0;
+    for(j=0; j<WORDS; j++){
+        /* Longest */
+        if(strlen(strs[j]) > lngst){
+            tstr = strduprev(strs[j]);
+            /* Not a palindrome */
+            if(strcmp(tstr, strs[j])){
+                /* Spelled correctly */
+                if((p = assoc_lookup(a, tstr))!=NULL){
+                    lngst = strlen(tstr);
+                    printf("%s <-> %s = %d (%d in the file)\n", tstr, strs[j], lngst, *(int*)p);
+                }
+            }
+            free(tstr);
+        }
+    }
+    assoc_free(a);
+
+    /*
+       Lets choose NUMRANGE numbers at random between 0 - (NUMRANGE-1)
+       and hash them.  Then assoc_count() tells us how many are unique
+    */
+    srand(time(NULL));
+    a = assoc_init(sizeof(int));
+    for(j=0; j<NUMRANGE; j++){
+        i[j] = rand()%NUMRANGE;
+        assoc_insert(&a, &i[j], NULL);
+    }
+    printf("%d unique numbers out of %d\n", assoc_count(a), j);
+
+    assoc_free(a);
+
+    return 0;
+}
+
+/* Make a copy, reversed */
+char* strduprev(char* str)
+{
+    int i, j;
+    char* t;
+    j = strlen(str);
+    t = ncalloc(j+1, 1); /* Add null char */
+    strcpy(t, str);
+    for(i=0, j--; i<j; i++,j--){
+        /* Swap using bit-twiddling */
+        t[i] ^= t[j];
+        t[j] ^= t[i];
+        t[i] ^= t[j];
+    }
+    return t;
+}
Index: ../chap5/*Simple Search/Binary Search.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//Driver Function\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <time.h>\n#define NMBRS 1000000\nint bin_it(int k, int *a, int l, int r);\nint main(void)\n{\n    int i, n;\n    int a[NMBRS];\n    srand(time(NULL));\n    for(i=0; i<NMBRS; i++){\n        a[i] = 2*i;//使得数组内数字为0，2，4，6，8，10……\n    }\n    for(i=0; i<10*NMBRS; i++){\n        n=bin_it(a[rand()%NMBRS], a, 0, NMBRS-1);//在数组a[]的1000000个数中随意选取一个来进行查找。\n        assert(n >= 0);\n    }\n    return 0;\n}\n\n//Iterative Binary Search 反复二分法查找\nint bin_it(int k, int *a, int l, int r)//本来没必要传l和r，为了和递归的格式类似，也传参数最左边的l和最右边的r\n{\n    int m;\n    while(l <= r){\n        m = (l+r)/2; //m是中间数的坐标\n        if(k == a[m]){\n            return m;//返回找到的坐标\n        }\n        else{\n            if (k > a[m]){\n                l = m + 1;//如果查找数比现在的中间数大，就把左边坐标右移，使得下次查找时中间数也变大。\n            }\n            else{\n                r = m- 1;\n            }\n        }\n    }\n    return -1;//找不到返回-1\n}\n\n//Recursive Binary Search\nint bin_rec(int k, int *a, int l, int r)\n{\n    int m;\n    if(l > r) return -1;\n    m = (l+r)/2;\n    if(k == a[m])\n        return m;\n    else{\n        if (k > a[m])\n            return bin_rec(k, a, m+1, r);\n        else\n            return bin_rec(k, a, l, m-1);\n    }\n}\n
===================================================================
--- ../chap5/*Simple Search/Binary Search.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/*Simple Search/Binary Search.c	(date 1615245742182)
@@ -1,4 +1,4 @@
-//Driver Function
+//Driver Function 二分法的基本思想都一致：与中位数的值比较，再与所属那一半范围的中位数比较，循环执行。
 #include <stdio.h>
 #include <stdlib.h>
 #include <assert.h>
@@ -45,7 +45,7 @@
 int bin_rec(int k, int *a, int l, int r)
 {
     int m;
-    if(l > r) return -1;
+    if(l > r) return -1;/* 以及覆盖这一片的所有数了，仍然找不到说明不存在。 */
     m = (l+r)/2;
     if(k == a[m])
         return m;
Index: ../chap5/*Simple Search/Ordered Sequential Search.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//Ordered Sequential Search\nint FindAge(char *name, Person *p, int n)\n{\n    int j, m;\n    for(j=0; j<n; j++){\n        m = strcmp(name, p[j].name);\n        if(m == 0)\n            return p[j].age;\n        if(m < 0)\n            return NOTFOUND;\n    }\n    return NOTFOUND;\n}\n
===================================================================
--- ../chap5/*Simple Search/Ordered Sequential Search.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/*Simple Search/Ordered Sequential Search.c	(date 1615245742187)
@@ -1,3 +1,27 @@
+//有序顺序查找。（这里的有序是指被查找的东西是有序的  如你要找Dxxx，那当你找到Exxx时，可以提前结束查找了）
+//应用例子：当你拿到了一个随机名单，要在已排序的字典里查找有无这个人，就是用到二分法
+#include <stdio.h>
+#include <string.h>
+#define NOTFOUND -1
+#define NUMPEOPLE 6
+struct person{
+    char *name;
+    int age;
+};
+typedef struct person Person;
+int FindAge(char *name, Person *l, int n);
+int main(void)
+{
+    //建一个装满struct的array
+    Person ppl[NUMPEOPLE] = {
+            {"Ackerby", 21}, {"Bloggs", 25},
+            {"Chumley", 26}, {"Dalton", 25},
+            {"Eggson", 22}, {"Fulton", 41} };
+    printf("%d\n", FindAge("Eggson", ppl, NUMPEOPLE));
+    printf("%d\n", FindAge("Campbell", ppl, NUMPEOPLE));
+    return 0;
+}
+
 //Ordered Sequential Search
 int FindAge(char *name, Person *p, int n)
 {
@@ -6,8 +30,9 @@
         m = strcmp(name, p[j].name);
         if(m == 0)
             return p[j].age;
+        //通过strcmp的返回值（ 小于0代表： 关键词/被查词<目前所在词，即查D但已经来到来E，同电话簿例子）来提前结束有序查找。
         if(m < 0)
             return NOTFOUND;
     }
-    return NOTFOUND;
+    return NOTFOUND;//作为flag变量 定义为-1
 }
Index: ../chap9/3nd Hashing/test.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <stdio.h>\n#include <string.h>\n#define SEED 131 /* seed取131，因为ASCII码表一共128个，131是128之后能取到的最小质数！*/\nunsigned int BKDRHash(void* key, int keySize, int size_hashArray);\nint main()\n{\n    void *key01,*key02,*key03,*key2,*keytest02,*olddata,*newdata;/* 没有给key赋值前，key是NULL指针！*/\n    float j = 11.05;\n    int i = 12;\n    int k = 13;\n    int hash01,hash02,hash03,hash2;\n    char* str = \"abc\";\n    char* str2 = \"abd\";\n    printf(\"%d\\n\",strcmp(str,str2));\n\n    key01 = &j;\n    key02 = &i;\n    key03 = &k;\n    key2 = str;\n    keytest02 = key02;\n\n    olddata = &i;\n    printf(\"%p\\n\",olddata);\n    newdata = &k;\n    printf(\"%p\\n\",newdata);\n    olddata = newdata;\n    printf(\"%p\\n\",olddata);\n\n    printf(\"ASCII: int %d %d %d and str %d.\\n\",*(char*)key01,*(char*)key02,*(char*)key03,*(char*)key2);\n\n    printf(\"%d\\n\",memcmp(key02,keytest02,4));\n    printf(\"%d\\n\",memcmp(key02,key03,4));\n\n    /*转换成char后，计算时这些*char相当于全都是int！！原本是字符的，用ASCII码算（如a:97）；原本是数字的，用其原数值算。*/\n    hash01 = BKDRHash(key01,4,16);\n    hash02 = BKDRHash(key02,4,16);\n    hash03 = BKDRHash(key03,4,16);\n    hash2 = BKDRHash(key2,0,16);\n    printf(\"hash: int %d %d %d and str %d.\\n\",hash01,hash02,hash03,hash2);\n\n    /* printf(\"The add of str is : %p\\n\",&str); 因为 %p 是 void*型，而 &str 是 char**型。所以不对*/\n    /* printf(\"The string of str is: %s\\n\",str);\n    printf(\"The string of key is: %s\\n\",(char*)key);\n    printf(\"The data of key is: %s\\n\",(char*)key); 此时无输出*/\n\n    return 0;\n}\nunsigned int BKDRHash(void* key, int keySize, int size_hashArray)\n{\n    unsigned int hash = 0;\n    char* p=key;\n    int i=0;\n    while( i++ < keySize || (keySize==0 && *p!='\\0')){\n        hash = hash * SEED + *(p++);\n    }\n    return hash % size_hashArray;\n}
===================================================================
--- ../chap9/3nd Hashing/test.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ Hashing/test.c	(date 1615245742412)
@@ -4,14 +4,19 @@
 unsigned int BKDRHash(void* key, int keySize, int size_hashArray);
 int main()
 {
-    void *key01,*key02,*key03,*key2,*keytest02,*olddata,*newdata;/* 没有给key赋值前，key是NULL指针！*/
+    void *key01,*key02,*key03,*key2,*keytest02,*olddata,*newdata,*keycell,*datacell;/* 没有给key赋值前，key是NULL指针！*/
     float j = 11.05;
     int i = 12;
     int k = 13;
     int hash01,hash02,hash03,hash2;
     char* str = "abc";
     char* str2 = "abd";
+    keycell=NULL;
     printf("%d\n",strcmp(str,str2));
+    keycell=str;
+    printf("%s\n",(char*)keycell);
+    datacell=NULL;
+
 
     key01 = &j;
     key02 = &i;
Index: Hashing/feedback/general
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Hashing/feedback/general	(date 1615245742387)
+++ Hashing/feedback/general	(date 1615245742387)
@@ -0,0 +1,39 @@
+People who had code that ran *very* slowly didn't seem to have understood
+that hashing is really fast compared to say an unsorted linear array -
+many programs would have been faster *not* using hashing :-( You should
+have tested that your code was indeed quicker than a very simple, rival,
+approach ?
+
+Quite a number chose to resize their array every time an insertion
+occurs. This totally destroys the power of hashing, and makes the approach
+(generally) slower than an unsorted linked list.
+
+Some people used a for() loop to iterate over the whole table during,
+e.g., an insertion - this can't possibly be right - it turns the O(1)
+algorithm into O(n).
+
+It's a little pedantic, but I liked that many people sorted their
+functions in their .c into the order that the .h file listed them,
+and then put "other" functions later. Some people followed my OOP-style
+convention of then naming those "private" functions in a systematic manner
+(e.g. with a _ preceding the name).
+
+Some people assumed that the key must be a string or an int - this is
+not the case - hashing unsigned long double (etc.) should be perfectly
+fine too. Some only used the first 4 bytes of the key to hash with in
+this case which is not correct - you could have been passing an entire
+190-byte struct and expecting a sensible hash to be returned ... This
+is what is meant by polymorphic ADTs.
+
+Some people seemed to have a sensible hash function for strings,
+but for other data didn't loop over all the bytes to compute a hash,
+they sometimes just took the first one - this will lead to a horrendous
+number of collisions resulting in O(n) (or worse) performance and my
+tests timing out ...
+
+For a small number of cases, I had to fix a compilation problem (e.g. switching
+the order of the specific & assoc #includes) - if this happened I will have mentioned
+this in the feedback somewhere.
+
+Some good solutions to this problem can be achieved in ~100 lines of code
+(excluding testing).
\ No newline at end of file
Index: ../chap5/*Simple Search/Sequential Search .c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//Sequential Search 1\n#include <stdio.h>\n#include <string.h>\n#define NOTFOUND -1\n#define NUMPEOPLE 6\nstruct person{\n    char *name;\n    int age;\n};\ntypedef struct person Person;\nint FindAge(char *name, Person *l, int n);\nint main(void)\n{\n    Person ppl[NUMPEOPLE] = {\n            {\"Ackerby\", 21}, {\"Bloggs\", 25},\n            {\"Chumley\", 26}, {\"Dalton\", 25},\n            {\"Eggson\", 22}, {\"Fulton\", 41} };\n    printf(\"%d\\n\", FindAge(\"Eggson\", ppl, NUMPEOPLE));\n    printf(\"%d\\n\", FindAge(\"Campbell\", ppl, NUMPEOPLE));\n    return 0;\n}\n\n
===================================================================
--- ../chap5/*Simple Search/Sequential Search .c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/*Simple Search/Sequential Search .c	(date 1615245742191)
@@ -1,4 +1,5 @@
-//Sequential Search 1
+//Sequential searching对于小list计算时间不长，但长list（比如电话簿）是低效率的
+//顺序查找。（这里的顺序是指逐个查找）
 #include <stdio.h>
 #include <string.h>
 #define NOTFOUND -1
@@ -11,6 +12,7 @@
 int FindAge(char *name, Person *l, int n);
 int main(void)
 {
+    //建一个装满struct的array
     Person ppl[NUMPEOPLE] = {
             {"Ackerby", 21}, {"Bloggs", 25},
             {"Chumley", 26}, {"Dalton", 25},
@@ -20,3 +22,14 @@
     return 0;
 }
 
+int FindAge(char *name, Person *p, int n)
+{
+    int j;
+    for(j=0; j<n; j++){
+        //p[].xxx 是字符串指针  因此可以比较字符串
+        if(strcmp(name, p[j].name) == 0){
+            return p[j].age;
+        }
+    }
+    return NOTFOUND;
+}
Index: ../chap5/Recursion/Power.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//Power\n/* Try to write power(a,b) to computer aˆb\nwithout using any maths functions other than\nmultiplication :\nTry (1) iterative then (2) recursive\n(3) Trick that for n%2==0, xˆn = xˆ(n/2)*xˆ(n/2)\n*/\n#include <stdio.h>\n#include <assert.h>\nvoid test();\nint power(unsigned int a, unsigned int b);\nint main(void)\n{\n    test();\n    int x = 2;\n    int y = 8;\n    printf(\"%dˆ%d = %d\\n\", x, y, power(x,y));\n    return 0;\n}\n/*\n//Iterative Version\nint power(unsigned int a, unsigned int b)\n{\n    unsigned int i,tot=a;\n\n    if(b==0){ //注意 0^0=1\n        return 1;\n    }\n    if(a==0){\n        return 0;\n    }\n    if(b==1){\n        return a;\n    }\n    for(i=2;i<=b;i++){//当b等于1时，a不应该与自己相乘;这里计数变量不能直接用\"b--\"，也不能直接循环做\"a*=a\"后返回\"a\"，\n        tot*=a;\n    }\n    return tot;//tot=total.\n}\n*/\n\n//Recursive Version\nint power(unsigned int a, unsigned int b)\n{\n    int t;//t的引入，使得后面return那一长串更简洁易懂\n    if(b==0){\n        return 1;\n    }\n    //Trick that for n%2==0, xˆn = xˆ(n/2)*xˆ(n/2)  -> 比前面要更快一点\n    if (b % 2 == 0) {\n        t=power(a, b/2);\n        return t*t;//无需在这里的return加上\"a*...\"因为无论是多大的偶数，递归后b总要从2（或3）变成1，而1要变成0，\n                   //又因为在1变0这趟中已经出现过一次a，因此函数哪其他部分的递归不需要带上a。\n    }\n    if(b%3==0){\n        t=power(a,b/3);\n        return t*t*t;\n    }\n    return a*power(a,b-1);//为奇数时或不满足上面快速执行的条件的，按正常的逐步递归方法。\n}\n\nvoid test()\n{\n    assert(power(0,0)==1);\n    assert(power(0,2)==0);\n    assert(power(2,0)==1);\n    assert(power(5,1)==5);\n    assert(power(2,8)==256);\n    assert(power(2,9)==512);\n    assert(power(2,16)==65536);\n    assert(power(9,2)==81);\n}\n
===================================================================
--- ../chap5/Recursion/Power.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/Power.c	(date 1615245742195)
@@ -17,19 +17,22 @@
     printf("%dˆ%d = %d\n", x, y, power(x,y));
     return 0;
 }
-/*
+
 //Iterative Version
 int power(unsigned int a, unsigned int b)
 {
     unsigned int i,tot=a;
 
-    if(b==0){ //注意 0^0=1
+    // a^0  注意 0^0=1
+    if(b==0){
         return 1;
     }
-    if(a==0){
+
+    if(a==0){ //0的非零整数次方，都为0
         return 0;
     }
-    if(b==1){
+    // a^1 = 1
+    if(b==1){ //非0数的非零次方，为1
         return a;
     }
     for(i=2;i<=b;i++){//当b等于1时，a不应该与自己相乘;这里计数变量不能直接用"b--"，也不能直接循环做"a*=a"后返回"a"，
@@ -37,26 +40,50 @@
     }
     return tot;//tot=total.
 }
-*/
 
 //Recursive Version
 int power(unsigned int a, unsigned int b)
+{
+    unsigned int i,tot=a;
+
+    // a^0,注意 0^0=1
+    if(b==0){
+        return 1;
+    }
+    // 0^b--非0数的非零次方，为1
+    if(a==0){
+        return 0;
+    }
+    // a^1 = 1--非0数的非零次方，为1
+    if(b==1){
+        return a;
+    }
+
+    //如何转换成递归： power(a,4) = a*a*a*a = a*power(a,3)
+    //         ---> return a * power(a,b-1)
+    return a*power(a,b-1);//tot=total.
+}
+
+
+// 第三种版本  Trick that for n%2==0, xˆn = xˆ(n/2)*xˆ(n/2) 比前面要更快一点
+int power(unsigned int a, unsigned int b)
 {
     int t;//t的引入，使得后面return那一长串更简洁易懂
     if(b==0){
         return 1;
     }
-    //Trick that for n%2==0, xˆn = xˆ(n/2)*xˆ(n/2)  -> 比前面要更快一点
-    if (b % 2 == 0) {
+
+    if (b % 2 == 0) {//如果b是偶数
+        //简化前： return power(a,b/2)*power(a,b/2);
         t=power(a, b/2);
-        return t*t;//无需在这里的return加上"a*..."因为无论是多大的偶数，递归后b总要从2（或3）变成1，而1要变成0，
-                   //又因为在1变0这趟中已经出现过一次a，因此函数哪其他部分的递归不需要带上a。
+        return t*t;//无论多大的偶数，相当于树的拆分，eg:36, 36/2/2/2/2……  递归后b总会从"2/3的倍数"拆解到"1"这个无因子可拆的阶段。
+                   //又因为a^1=a 这里出现了a，所以函数开始递归时不需要带上a。
     }
     if(b%3==0){
         t=power(a,b/3);
         return t*t*t;
     }
-    return a*power(a,b-1);//为奇数时或不满足上面快速执行的条件的，按正常的逐步递归方法。
+    return a*power(a,b-1);//其他不满足上面"fast pass"（即除了占绝大多数的偶数 或 3的倍数外）的质数，按"逐级递减"的正常递归来做。
 }
 
 void test()
Index: Hashing/feedback/personal
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Hashing/feedback/personal	(date 1615245742380)
+++ Hashing/feedback/personal	(date 1615245742380)
@@ -0,0 +1,19 @@
+Individual Feedback
+-------------------
+
+./Realloc/realloc.c
+Running testassoc1 ... Looks Good
+Running testassoc2 ... Looks Good (631920 Unique Numbers)
+Running testassoc3 ... Running testassoc3 ... Looks Good
+Running testassoc4 ... Looks Good (repeated init/free) 972kbytes 0.51secs
+Running testassoc5 ... Looks Good (assoc_count(NULL)==0)
+Running testassoc6 ... Looks Good (storing value as pointer, not copied)
+Sanitizing testassoc1 ... Looks Good
+Sanitizing testassoc2 ... Looks Good
+Valgrind testassoc3 ... Looks Good
+Cuckoo&testassoc1 ... Looks Good
+Cuckoo testassoc4 ... Looks Good (repeated init/free) 968kbytes 0.51secs
+Sanitizing Cuckoo&testassoc1 ... Looks Good
+Initial Mark = 69
+Final Mark = 74
+[FINALCOMMENT] Nicely done - hash used is interesting, good coding style generally.
\ No newline at end of file
Index: ../chap5/Recursion/Permuting .c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//Permuting 排列\n/* Borrowed from e.g.\nhttp://www.geeksforgeeks.org\n*/\n#include <stdio.h>\n#include <string.h>\n\nvoid swap(char* x,char* y);\nvoid permute(char* a, int lf,int rt);\nint main()\n{\n    char str[] = \"ABCD\";\n    int n = strlen(str);\n    permute(str, 0, n-1);//把字符串传给这个递归函数，而且看起来是交换头尾的格子值\n    return 0;\n}\n\nvoid permute(char* s, int lf, int rt)\n{\n    int i;\n    if (lf == rt){\n        printf(\"%s\\n\", s);\n        return;\n    }\n    else{\n        for(i = lf; i <= rt; i++){//进行一次首尾交换后D不变，后面XXX出现6个组合：ABC,ACB,BAC,BCA,CAB,CBA.\n            printf(\"Initially -> %s\\n\",&s[lf]);//方便查看和检验每次交换了哪两个。\n            swap(&s[lf],&s[i]);permute(s, lf+1, rt);//每次调用一次p之前就交换一次，这里lf与i坐标对应的格子交换值。 i=lf表明此时不交换/为原值。\n            swap(&s[lf],&s[i]);//Backtrack变回交换前的样子，因为要通过循环遍历24个组合（每次调用permute时所传参数，都作为新循环中的计数变量初始值）。\n        }\n    }\n}\n\nvoid swap(char* x,char* y)\n{\n    char temp;\n    temp=*x;\n    *x=*y;\n    *y=temp;\n}\n\n\n\n
===================================================================
--- ../chap5/Recursion/Permuting .c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/Permuting .c	(date 1615245742200)
@@ -24,9 +24,11 @@
     }
     else{
         for(i = lf; i <= rt; i++){//进行一次首尾交换后D不变，后面XXX出现6个组合：ABC,ACB,BAC,BCA,CAB,CBA.
-            printf("Initially -> %s\n",&s[lf]);//方便查看和检验每次交换了哪两个。
+            /*printf("Initially -> %s\n",&s[lf]);//方便查看和检验每次交换前选中序列的样子。下面语句直接检查交换了哪两个。*/
+            printf("Swaping %c with %c\n",s[lf],s[rt]);
             swap(&s[lf],&s[i]);permute(s, lf+1, rt);//每次调用一次p之前就交换一次，这里lf与i坐标对应的格子交换值。 i=lf表明此时不交换/为原值。
-            swap(&s[lf],&s[i]);//Backtrack变回交换前的样子，因为要通过循环遍历24个组合（每次调用permute时所传参数，都作为新循环中的计数变量初始值）。
+            //Backtrack变回交换前的样子，因为要通过循环遍历24个组合（每次调用permute时所传参数，都作为新循环中的计数变量初始值）。
+            swap(&s[lf],&s[i]);
         }
     }
 }
Index: ../chap5/Recursion/maze.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//The Ubiquitous Maze\n#include <stdio.h>\n#include <string.h>\nenum bool{false,true};\ntypedef enum bool bool;\n#include \"neillsimplescreen\"\n\n#define HEIGHT 10\n#define WIDTH 10\n#define START_X 1\n#define START_Y 0\n\n//W=walls, H=holes, X=exits, P=path, T=visited(不需要重复访问)\n#define W '#'\n#define H ' '\n#define X '*'\n#define P '.'\n#define T 'T'\n\nvoid print_maze(char maze[HEIGHT][WIDTH]);\nbool explore(int x, int y, char mz[YS][XS]);\nint main()\n{\n    char maze[HEIGHT][WIDTH]={{W,H,W,W,W,W,W,W,W,W},\n                              {W,H,W,H,H,H,W,H,H,X},\n                              {W,H,W,H,W,H,H,H,W,W},\n                              {W,H,W,H,W,H,W,H,H,W},\n                              {W,H,W,H,W,H,W,H,W,W},\n                              {W,H,H,H,W,H,W,H,W,W},\n                              {W,H,H,H,W,H,W,H,H,W},\n                              {W,H,W,H,W,H,W,H,W,W},\n                              {W,H,H,H,W,H,H,H,W,W},\n                              {W,W,W,W,W,W,W,W,W,W}};\n    print_maze(maze);\n    if(explore(START_X,START_Y,maze)){\n        printf(\"\\n\");\n        maze[START_Y][START_X]=H;\n        print_maze(maze);\n    }\n    else{\n        printf(\"No Valid Route?\\n\");\n    }\n    return 0;\n}\n\nvoid print_maze(char maze[HEIGHT][WIDTH])\n{\n    int i,j;\n    char c;\n    for(j=0;j<HEIGHT;j++){\n        for(i=0;i<WIDTH;i++){\n            c=maze[j][i];\n            switch (c) {\n                case H:\n                case X:\n                case W:\n                    neillfgcol(green);\n                    break;\n                case T:\n                    c=' ';\n                    break;\n                default:\n                    neillfgcol(red);\n            }\n            printf(\"%c\",c);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    neillreset()l\n}\n\nbool explore(int x, int y, char mz[YS][XS])\n{\n    if(mz[y][x]==X){\n        return 1;\n    }\n    if(explore(x, y+1, mz)){//if we can go up\n        return 1;\n    }\n    if(explore(x+1, y, mz)){//if we can go right\n        return 1;\n    }\n    if(explore(x, y-1, mz)){//if we can go down\n        return 1;\n    }\n    if(explore(x-1, y, mz)){//if we can go left\n        return 1;\n    }\n    mz[y][x]=T;\n\n\n\n\n    /*\n        if mz[y][x] is exit, return 1;\n    Mark mz[y][x] so we don’t return here\n    if we can go up :\n        if(explore(x, y+1, mz)) return 1;\n    if we can go right :\n        if(explore(x+1, y, mz)) return 1;\n        Do left & down in a similar manner\n    return 0; -> Failed to find route */\n}\n\n\n
===================================================================
--- ../chap5/Recursion/maze.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/maze.c	(date 1615245742205)
@@ -1,63 +1,64 @@
-//The Ubiquitous Maze
+/* The Ubiquitous Maze*/
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
-enum bool{false,true};
-typedef enum bool bool;
-#include "neillsimplescreen"
+#include <ctype.h>
+#include <assert.h>
+#include "neillsimplescreen.h"
+#define MAX_HEIGHT 20
+#define MAX_WIDTH 20
+typedef enum bool{false,true} bool;
+struct maze{
+    char mz[MAX_HEIGHT][MAX_WIDTH];
+    int HEIGHT;
+    int WIDTH;
+    int START_X;
+    int START_Y;
+};
 
-#define HEIGHT 10
-#define WIDTH 10
-#define START_X 1
-#define START_Y 0
-
-//W=walls, H=holes, X=exits, P=path, T=visited(不需要重复访问)
+/* W=walls, H=holes, X=exits, T=死胡同*/
 #define W '#'
 #define H ' '
 #define X '*'
-#define P '.'
 #define T 'T'
 
-void print_maze(char maze[HEIGHT][WIDTH]);
-bool explore(int x, int y, char mz[YS][XS]);
-int main()
+void test(void);
+void file2maze(int numInput, const char* filename,struct maze *p);
+void findStart(struct maze *p);
+void print_maze(struct maze p);
+bool explore(int x, int y, struct maze *p);
+bool valid(int x, int y, struct maze p);
+int main(int argc, const char* argv[])
 {
-    char maze[HEIGHT][WIDTH]={{W,H,W,W,W,W,W,W,W,W},
-                              {W,H,W,H,H,H,W,H,H,X},
-                              {W,H,W,H,W,H,H,H,W,W},
-                              {W,H,W,H,W,H,W,H,H,W},
-                              {W,H,W,H,W,H,W,H,W,W},
-                              {W,H,H,H,W,H,W,H,W,W},
-                              {W,H,H,H,W,H,W,H,H,W},
-                              {W,H,W,H,W,H,W,H,W,W},
-                              {W,H,H,H,W,H,H,H,W,W},
-                              {W,W,W,W,W,W,W,W,W,W}};
-    print_maze(maze);
-    if(explore(START_X,START_Y,maze)){
+    struct maze m={{{0}},0,0,0,0};
+    file2maze(argc,argv[1],&m);
+    test();
+    findStart(&m);
+    print_maze(m);
+    if (explore(m.START_X,m.START_Y,&m)) {/* 从起点开始explore,只有该函数递归的每一层遍历都返回1，从没出现过0才最终得1(否则该树分支结果为0)也就是只有能通向终点的路线可以被打印！*/
         printf("\n");
-        maze[START_Y][START_X]=H;
-        print_maze(maze);
-    }
-    else{
+        print_maze(m);
+    } else {
         printf("No Valid Route?\n");
+        exit(EXIT_FAILURE);
     }
     return 0;
 }
 
-void print_maze(char maze[HEIGHT][WIDTH])
+void print_maze(struct maze p)
 {
     int i,j;
     char c;
-    for(j=0;j<HEIGHT;j++){
-        for(i=0;i<WIDTH;i++){
-            c=maze[j][i];
+    for(j=0;j<p.HEIGHT;j++){
+        for(i=0;i<p.WIDTH;i++){
+            c=p.mz[j][i];
             switch (c) {
                 case H:
-                case X:
                 case W:
-                    neillfgcol(green);
+                    neillfgcol(green);/* green=unvisited, unchanged*/
                     break;
                 case T:
-                    c=' ';
+                    c=' ';/*把走到死胡同已经无路可走的格子，用标记T表示，使得探索时不会重复走无效路。然后在打印函数中，再将这些空格表示回空格的形式！*/
                     break;
                 default:
                     neillfgcol(red);
@@ -67,40 +68,145 @@
         printf("\n");
     }
     printf("\n");
-    neillreset()l
+    neillreset();/* 颜色复原 */
 }
 
-bool explore(int x, int y, char mz[YS][XS])
+/* Valid函数用于检查被探索格是否在边界内！ */
+bool valid(int x, int y, struct maze p)
 {
-    if(mz[y][x]==X){
-        return 1;
+    if((x<0)||(y<0)||(x>=p.WIDTH)||(y>=p.HEIGHT)){
+        return false;
     }
-    if(explore(x, y+1, mz)){//if we can go up
-        return 1;
+    if(p.mz[y][x]!=X && p.mz[y][x]!=H){
+        return false;
     }
-    if(explore(x+1, y, mz)){//if we can go right
-        return 1;
-    }
-    if(explore(x, y-1, mz)){//if we can go down
-        return 1;
+    return true;
+}
+
+bool explore(int x, int y, struct maze *p)
+{
+    /*也相当于从终点往起点倒过来找可行的路，因为只有终点是最终返回可确定的值1。终点附近的点explore到终点所以返回1，而这些点附近的点explore到返回1的点所以返回1，不断递归到起点。
+    //对于返回值为1的方块，其1步长范围内的方块也使其返回1，相当于做"树"层层遍历找到通向终点/起点的"路"。*/
+    if(p->mz[y][x]==X){/* 递归的边界条件*/
+        return true;
     }
-    if(explore(x-1, y, mz)){//if we can go left
-        return 1;
-    }
-    mz[y][x]=T;
+
+    /* if we can go up, down, right, or left, return 1.
+    // Mark mz[y][x] so we don’t return here */
+    if(valid(x+1, y, *p)) {
+        p->mz[y][x]='>';
+        if(explore(x+1,y,p)){
+            return true;
+        }
+        /* 如果explore单方向失败，有必要把格子改回原状态。因为有可能这个坐标在后面的其他方向也探索失败，无法覆盖已有方向符号 */
+        p->mz[y][x]=H;
+    }
+
+    if(valid(x-1, y, *p)) {
+        p->mz[y][x]='<';
+        if(explore(x-1,y,p)){
+            return true;
+        }
+        p->mz[y][x]=H;
+    }
+
+    if(valid(x, y+1, *p)) {
+        p->mz[y][x]='v';
+        if(explore(x,y+1,p)){
+            return true;
+        }
+        p->mz[y][x]=H;
+    }
+
+    if(valid(x, y-1, *p)) {
+        p->mz[y][x]='^';
+        if(explore(x,y-1,p)){
+            return true;
+        }
+        p->mz[y][x]=H;
+    }
+    /* Failed to find route */
+    p->mz[y][x]=T;/* 这里不可以用else——因为当遇到死角后返回时，如果else的话就只包括"四个方向都不可探索"，但不包括"前面有一方向可以探索，但那个方向遇到死角"的情况！*/
+    return false;
+}
 
+void file2maze(int numInput, const char* filename,struct maze *p)
+{
+    FILE *fp;
+    int n=0;
+    char str[MAX_WIDTH];
+    int finished;
+    if(numInput>=2) {
+        fp = fopen(filename, "r");
+        if (fp == NULL) {
+            fprintf(stderr, "Cannot open file\n");
+            exit(EXIT_FAILURE);
+        }
+    }else{
+        printf("Pls enter the filename!\n");
+        exit(EXIT_FAILURE);
+    }
 
+    do{
+        finished = false;
+        if(fgets(str,MAX_WIDTH,fp) == NULL){
+            finished = true;/*如果fgets遇到非空行，执行else，并继续循环直到遇到NULL;若遇到NULL，则由While结束循环*/
+        }
+        else {
+            if (isdigit(str[0])) {
+                if (sscanf(str, "%d %d", &p->WIDTH, &p->HEIGHT) != 2) {
+                    fprintf(stderr, "Cannot read file.\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else {
+                /*此时才排除了所有出错情况（文件打不开、首行为空因此返回NULL、sscanf得到的数字个数不足）。此时可以拷贝字符串数组内容。*/
+                strncpy(p->mz[n++], str, p->WIDTH);/* 用fgets时无需手动加结束符，每一行它获取完毕会自动加一个结束符在结尾。*/
 
+            }
+        }
+    }while(!finished);/* 首行不为空时，扫得到了，完成状态为1了，就不执行。 */
+    fclose(fp);
+}
 
-    /*
-        if mz[y][x] is exit, return 1;
-    Mark mz[y][x] so we don’t return here
-    if we can go up :
-        if(explore(x, y+1, mz)) return 1;
-    if we can go right :
-        if(explore(x+1, y, mz)) return 1;
-        Do left & down in a similar manner
-    return 0; -> Failed to find route */
+void findStart(struct maze *p)
+{
+    int S=0;
+    int i,j;
+    do{
+        for(j=0;j<=S;j++) {
+            for (i = 0; i<=S; i++) {
+                if (p->mz[j][i] == ' ') {
+                    p->START_Y = j;
+                    p->START_X = i;
+                    return;
+                }
+            }
+        }
+        S++;
+    }while(S<=p->WIDTH);
+    printf("Cannot find the start?\n");
+    exit(EXIT_FAILURE);
 }
 
+void test(void)
+{
+    struct maze t= {{{W, H, W, W, W, W, W, W, W, W},
+                     {W, H, W, H, H, H, W, H, H, X},
+                     {W, H, W, H, W, H, H, H, W, W},
+                     {W, H, W, H, W, H, W, H, H, W},
+                     {W, H, W, H, W, H, W, H, W, W},
+                     {W, H, H, H, W, H, W, H, W, W},
+                     {W, H, H, H, W, H, W, H, H, W},
+                     {W, H, W, H, W, H, W, H, W, W},
+                     {W, H, H, H, W, H, H, H, W, W},
+                     {W, W, W, W, W, W, W, W, W, W}},10,10,1,0};
+    assert(explore(9,1,&t));
+    assert(explore(8,1,&t));
+    t.mz[6][7]='>';
+    assert(!explore(6,8,&t));
 
+    assert(!valid(0,0,t));
+    assert(!valid(10,0,t));
+    assert(!valid(1,-1,t));
+    assert(!valid(10,0,t));
+}
Index: ../chap5/Recursion/str_reverse.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//Iterative String Reverse\n\n#include <stdio.h>\n#include <string.h>\n#define SWAP(A,B) {char temp; temp=A;A=B;B=temp;}//将函数定义语句放在define这，\nvoid Reverse_String(char *s, const int start, int end);\nint main(void)\n{\n    char str[] = \"Hello World!\";\n    Reverse_String(str, 0, strlen(str)-1);//传递字符长度-1，因为对于长度为5的字符串，要讲格子0和4交换，下面j可以直接用n。\n    printf(\"%s\\n\", str);\n    return 0;\n}\n/* Iterative Inplace String Reverse */\nvoid Reverse_String(char *s, const int start, int end)\n{\n    int i, j;\n    for(i=0, j=n; i<j; i++, j--){\n        /*SWAP(&s[i], &s[j]); ️向函数传递 地址/指针，这样函数就具备了直接修改这两个值自身的能力！（更适合于int等函数不return无法直接改变的）*/\n        SWAP(s[i], s[j]);//但对于数组来说，直接进行s[i]s[j]的交换赋值可以传回来。（数组型可以直接改变）\n    }\n}\n\n//Recursive String Reverse\n#include <stdio.h>\n#include <string.h>\n#define SWAP(A,B) {char temp; temp=A;A=B;B=temp;}\nvoid Reverse_String(char *s, int start,);\nint main(void)\n{\n    char str[]= \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    Reverse_String(str, 0, strlen(str)-1);\n    printf(\"%s\\n\", str);\n}\n/* RECURSIVE : Inplace String Reverse */\nvoid Reverse_String(char *s, int start, int end)\n{\n    if(start >= end){\n        return;\n    }\n    SWAP(s[start], s[end]);\n    Reverse_String(s, start+1, end-1);\n}\n
===================================================================
--- ../chap5/Recursion/str_reverse.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/str_reverse.c	(date 1615245742211)
@@ -3,16 +3,16 @@
 #include <stdio.h>
 #include <string.h>
 #define SWAP(A,B) {char temp; temp=A;A=B;B=temp;}//将函数定义语句放在define这，
-void Reverse_String(char *s, const int start, int end);
+void Reverse_String(char *s, const int n);
 int main(void)
 {
     char str[] = "Hello World!";
-    Reverse_String(str, 0, strlen(str)-1);//传递字符长度-1，因为对于长度为5的字符串，要讲格子0和4交换，下面j可以直接用n。
+    Reverse_String(str, strlen(str)-1);//传递字符长度-1，因为对于长度为5的字符串，要讲格子0和4交换，下面j可以直接用n。
     printf("%s\n", str);
     return 0;
 }
 /* Iterative Inplace String Reverse */
-void Reverse_String(char *s, const int start, int end)
+void Reverse_String(char *s, const int n)
 {
     int i, j;
     for(i=0, j=n; i<j; i++, j--){
@@ -21,23 +21,24 @@
     }
 }
 
-//Recursive String Reverse
+//------------Recursive String Reverse------------
 #include <stdio.h>
 #include <string.h>
 #define SWAP(A,B) {char temp; temp=A;A=B;B=temp;}
-void Reverse_String(char *s, int start,);
+//迭代版将字符串颠倒，从"在函数内用两个计数变量i、j"，变为更有效的每次直接传递这两个计数变量，
+void Reverse_String(char *s, int start, int end);
 int main(void)
 {
     char str[]= "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-    Reverse_String(str, 0, strlen(str)-1);
+    Reverse_String(str, 0, strlen(str)-1);//首次传参，相当于"i=0,j=n"
     printf("%s\n", str);
 }
 /* RECURSIVE : Inplace String Reverse */
 void Reverse_String(char *s, int start, int end)
 {
-    if(start >= end){
+    if(start >= end){//作为每次递归的basic基本条件（边界条件）判断埋在函数里--要写在递归函数的最前面，相当于"i<j"
         return;
     }
-    SWAP(s[start], s[end]);
-    Reverse_String(s, start+1, end-1);
+    SWAP(s[start], s[end]);//将要交换的开头格子和结尾格子，重命名为start、end更直观
+    Reverse_String(s, start+1, end-1);//不断call调用自己这个函数，调用时传参之处是值会变化的表达式（传递"s+1"和"e-1"就相当于"i++,j--"）
 }
Index: ../2nd/bookcase.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n#include <assert.h>\n#define MAXCOLUMN 9\n#define MAXROW 9\n#define FAILURE -1\n#define LIST_INIT_SIZE 1000\n#define EXPFACTOR 2\n#define ERROR(PHRASE) {fprintf(stderr,\"%s\\n\",PHRASE);exit(EXIT_FAILURE);}\n\nenum bool{false,true};\ntypedef enum bool bool;\n\ntypedef struct array_node{\n    char bookcase[row][column];\n    int current;\n    int parent;\n}array_node;\n\ntypedef struct list{\n    array_node *node;\n    int size;\n    int capacity;\n}list;\n\nvoid readfile(const char* filename,char *grid[MAXROW][MAXCOLUMN],int *row,int *column);\nvoid create_children(list *l,char bc[row][column],int row,int column);\nchar** move(char bc[row][column],int line1,int line2,int row,int column);\nint find_rightmostBook(char bc[row][column],int y,int row,int column);\nint find_space(char bc[row][column],int y,int row,int column);\nbool check_happiness(char bc[row][column],int row,int column);\nbool check_oneline_onecolor(char bc[row][column],int row,int column);\nbool check_onecolor_oneline(char bc[row][column],int row,int column);\nlist* list_init(void);\nvoid list_add(list *l, char** bc,int row,int column);\nvoid list_free(list *l);\nvoid printBoard(char bc[row][column],int row,int column);\nvoid printList(list *l);\nvoid test();\nint main(int argc, char const *argv[])\n{\n    char bookcase[MAXROW][MAXCOLUMN];\n    int row,column;\n    int i=0,j=0;\n    if(argc>=2){\n        readfile(argv[1],bookcase,&row,&column);\n    }\n    else{\n        ERROR(\"no input file?\");\n    }\n    test();\n    list* l=list_init(bookcase);\n    list_add(l,bookcase,row,column);\n    while(!check_happiness(l->node[i].bookcase,row,column)){\n        create_children(l,l->node[i].bookcase,row,column);\n        i++;\n    }\n\n    for(j=0;j<g;j++){\n        if(check_happiness(l->node[j].bookcase,row,column)){\n            printList(l);\n        }\n    }\n    list_free(l);\n    return 0;\n}\n\nvoid readfile(const char* filename,char grid[MAXROW][MAXCOLUMN],int *row,int *column)\n{\n    FILE* file;\n    char str[10];\n    int y, x ;\n    file = fopen(filename, \"r\");\n    if (file == NULL) {\n        ERROR(\"file not found\");\n    }\n/* check the first line, get the row and the column */\n    if(fgets(str,10,file) != NULL){\n        if(sscanf(str,\"%d%d\",row,column) != 2){\n            ERROR(\"invalid head line\");\n        }\n    }\n/* get the bookcase */\n    y = 0;\n    while(fgets(str,10,file) != NULL){\n        x = 0;\n        if (y >= *row) {\n            ERROR(\"incorrect row number. \");\n        }\n        while(x < *column){\n            if (str[x]!='.'&&!isalpha(str[x])) {\n                ERROR(\"invalid characters.\");\n            }\n            if(isalpha(str[x])){\n                str[x]=toupper(str[x]);\n            }\n            grid[y][x] = str[x];\n            x ++;\n        }\n        y ++;\n    }\n    fclose(file);\n}\n\nvoid printList(list *l)\n{\n    \n}\n\nlist* list_init(void)\n{\n    list* l = (list*)calloc(sizeof(list),1);\n    if(l == NULL)\n    {\n        return NULL;\n    }\n    l->node = (array_node*)calloc(sizeof(array_node),LIST_INIT_SIZE);\n    if(l->node == NULL)\n    {\n        free(l);\n        return NULL;\n    }\n    l->size = 0;\n    l->capacity = LIST_INIT_SIZE;\n    return l;\n}\n\nvoid create_children(struct list *l,char bc[row][column],int row,int column)\n{\n    int y1,y2;\n    char** p;\n    for(y1=0;y1<row;y1++){\n        for(y2=0;(y2!=y1)&&(y2<row);y2++){\n            p=move(bc,y1,y2,row,column);\n            if(p){\n                list_add(l,p,row,column);\n            }\n        }\n    }\n}\n\nvoid list_add(list *l, char** bc,int row,int column)\n{\n    int i;\n    if(l) {\n        for (i = 0; i<row; i++) {\n            strncpy(l->node[l->size].bookcase[i],bc[i],column);\n        }\n        l->node[l->size].current=l->size;\n        l->node[l->size].parent=;\n        l->size = l->size + 1;\n        if (l->size == l->capacity - 1) {\n            l->node = (array_node *) realloc(l->node,sizeof(array_node) * pow(l->capacity,EXPFACTOR));\n            if (l->node == NULL) {\n                free(l->node);\n                puts(\"Collection overflow\");/* on_error(\"...\") */\n                exit(1);\n            }\n            l->capacity = pow(l->capacity,EXPFACTOR);\n        }\n    }\n}\n\nvoid list_free(list *l)\n{\n    if(l == NULL)\n        return;\n    if(l->node != NULL)\n    {\n        free(l->node);\n        l->node = NULL;\n    }\n    if(l != NULL)\n    {\n        free(l);\n        l = NULL;\n    }\n}\n\n\n\nvoid printBoard(char bc[row][column],int row,int column)\n{\n    int i,j;\n    for(j=0;j<row;j++){\n        for(i=0;i<column;i++){\n            printf(\"%c \",bc[j][i]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nchar** move(char bc[row][column],int line1,int line2,int row,int column)\n{\n    int i,col1,col2;\n    char **new;\n    new=(char**)malloc(row*sizeof(char*));\n    for (i = 0; i<row; i++) {\n        new[i] = (char *) malloc(column * sizeof(char));\n        strncpy(new[i],bc[i],column);\n    }\n    if(find_rightmostBook(bc, line1)!=FAILURE && find_space(bc, line2) != FAILURE) {\n        col1 = find_rightmostBook(bc, line1);\n        col2 = find_space(bc, line2);\n        new[line2][col2] = bc[line1][col1];\n        new[line1][col1] = '.';\n        return new;\n    }\n    return NULL;\n}\n\n\nint find_rightmostBook(char bc[row][column],int y,int row,int column)\n{\n    int x;\n    /* when the shelf is full, the rightmost book is on the boundary of the shelf. */\n    if(isupper(bc[y][column-1])){\n        return column-1;\n    }\n    for (x = 0; (x + 1) < column; x++) {\n        /* when the shelf is not full, the rightmost book is near an empty grid. */\n        if (isupper(bc[y][x]) && (!isupper(bc[y][x + 1]))) {\n            return x;\n        }\n    }\n    return FAILURE;\n}\n\n\nint find_space(char bc[row][column],int y,int row,int column)\n{\n    int x;\n    /* when the shelf is empty, the first grid is good to place a book. */\n    if(bc[y][0]=='.'){\n        return 0;\n    }\n    /* when the shelf is not empty, find the first empty grid next to a book. */\n    for(x=1;(x+1)<column;x++){\n        if(isupper(bc[y][x])&&!isupper(bc[y][x+1])){\n            return x+1;\n        }\n    }\n    return FAILURE;\n}\n\n\nbool check_happiness(char bc[row][column],int row,int column)\n{\n    if (check_oneline_onecolor(bc)&&check_onecolor_oneline(bc)){\n        return true;\n    }\n    return false;\n}\n\nbool check_oneline_onecolor(char bc[row][column],int row,int column)\n{\n    int i,j;\n    char temp;\n    for(i=0;i<row;i++){\n        for(j=0;isupper(bc[i][j]);j++) {\n            if (j == 0) {\n                temp = bc[i][0];\n            }\n            else{\n                if (bc[i][j] != temp) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nbool check_onecolor_oneline(char bc[row][column],int row,int column)\n{\n    int i,r;\n    for(i=0;i<(row-1);i++){\n        for(r=i+1;r<row;r++){\n            if(isupper(bc[i][0])) {\n                if ((i != r) && (bc[i][0] == bc[r][0])) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n\n\nvoid test()\n{\n\n\n\n}\n\n
===================================================================
--- ../2nd/bookcase.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../2nd/bookcase.c	(date 1615245742216)
@@ -31,9 +31,9 @@
 char** move(char bc[row][column],int line1,int line2,int row,int column);
 int find_rightmostBook(char bc[row][column],int y,int row,int column);
 int find_space(char bc[row][column],int y,int row,int column);
-bool check_happiness(char bc[row][column],int row,int column);
-bool check_oneline_onecolor(char bc[row][column],int row,int column);
-bool check_onecolor_oneline(char bc[row][column],int row,int column);
+bool check_happiness(char bc[row][column],int row);
+bool check_oneline_onecolor(char bc[row][column],int row);
+bool check_onecolor_oneline(char bc[row][column],int row);
 list* list_init(void);
 void list_add(list *l, char** bc,int row,int column);
 void list_free(list *l);
@@ -52,7 +52,7 @@
         ERROR("no input file?");
     }
     test();
-    list* l=list_init(bookcase);
+    list* l=list_init();
     list_add(l,bookcase,row,column);
     while(!check_happiness(l->node[i].bookcase,row,column)){
         create_children(l,l->node[i].bookcase,row,column);
@@ -105,11 +105,6 @@
     fclose(file);
 }
 
-void printList(list *l)
-{
-    
-}
-
 list* list_init(void)
 {
     list* l = (list*)calloc(sizeof(list),1);
@@ -128,20 +123,6 @@
     return l;
 }
 
-void create_children(struct list *l,char bc[row][column],int row,int column)
-{
-    int y1,y2;
-    char** p;
-    for(y1=0;y1<row;y1++){
-        for(y2=0;(y2!=y1)&&(y2<row);y2++){
-            p=move(bc,y1,y2,row,column);
-            if(p){
-                list_add(l,p,row,column);
-            }
-        }
-    }
-}
-
 void list_add(list *l, char** bc,int row,int column)
 {
     int i;
@@ -150,7 +131,6 @@
             strncpy(l->node[l->size].bookcase[i],bc[i],column);
         }
         l->node[l->size].current=l->size;
-        l->node[l->size].parent=;
         l->size = l->size + 1;
         if (l->size == l->capacity - 1) {
             l->node = (array_node *) realloc(l->node,sizeof(array_node) * pow(l->capacity,EXPFACTOR));
@@ -164,6 +144,43 @@
     }
 }
 
+
+
+void create_children(struct list *l,char bc[row][column],int row,int column)
+{
+    int y1,y2;
+    char** p;
+    for(y1=0;y1<row;y1++){
+        for(y2=0;(y2!=y1)&&(y2<row);y2++){
+            p=move(bc,y1,y2,row,column);
+            if(p){
+                list_add(l,p,row,column);
+            }
+        }
+    }
+}
+
+char** move(char bc[row][column],int line1,int line2,int row,int column)
+{
+    int i,col1,col2;
+    char **new;
+    new=(char**)malloc(row*sizeof(char*));
+    for (i = 0; i<row; i++) {
+        new[i] = (char *) malloc(column * sizeof(char));
+        strncpy(new[i],bc[i],column);
+    }
+    if(find_rightmostBook(bc, line1)!=FAILURE && find_space(bc, line2) != FAILURE) {
+        col1 = find_rightmostBook(bc, line1);
+        col2 = find_space(bc, line2);
+        new[line2][col2] = bc[line1][col1];
+        new[line1][col1] = '.';
+        return new;
+    }
+    return NULL;
+}
+
+
+
 void list_free(list *l)
 {
     if(l == NULL)
@@ -193,25 +210,10 @@
     }
 }
 
-char** move(char bc[row][column],int line1,int line2,int row,int column)
+void printList(list *l)
 {
-    int i,col1,col2;
-    char **new;
-    new=(char**)malloc(row*sizeof(char*));
-    for (i = 0; i<row; i++) {
-        new[i] = (char *) malloc(column * sizeof(char));
-        strncpy(new[i],bc[i],column);
-    }
-    if(find_rightmostBook(bc, line1)!=FAILURE && find_space(bc, line2) != FAILURE) {
-        col1 = find_rightmostBook(bc, line1);
-        col2 = find_space(bc, line2);
-        new[line2][col2] = bc[line1][col1];
-        new[line1][col1] = '.';
-        return new;
-    }
-    return NULL;
-}
 
+}
 
 int find_rightmostBook(char bc[row][column],int y,int row,int column)
 {
@@ -247,15 +249,15 @@
 }
 
 
-bool check_happiness(char bc[row][column],int row,int column)
+bool check_happiness(char bc[row][column],int row)
 {
-    if (check_oneline_onecolor(bc)&&check_onecolor_oneline(bc)){
+    if (check_oneline_onecolor(bc,row)&&check_onecolor_oneline(bc,row)){//eachline_onecolor, eachcolor_oneline
         return true;
     }
     return false;
 }
 
-bool check_oneline_onecolor(char bc[row][column],int row,int column)
+bool check_oneline_onecolor(char bc[row][column],int row)
 {
     int i,j;
     char temp;
@@ -274,7 +276,7 @@
     return true;
 }
 
-bool check_onecolor_oneline(char bc[row][column],int row,int column)
+bool check_onecolor_oneline(char bc[row][column],int row)
 {
     int i,r;
     for(i=0;i<(row-1);i++){
Index: ../chap5/Recursion/fibonacci.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//Iteration & Fibonacci Sequences\n/* 递归 recursion：函数调用自己。（When a function calls itself）好处是省时，简化和美化程序。\n   斐波那契数列：\n        fib(1) is 1\n        fib(2) is 1\n        fib(n) is fib(n-1)+fib(n-2)\n        1,1,2,3,5,8,13,21, ... 每个数是前两位数字的和。\n */\n#include <stdio.h>\nint fibonacci(int n);\nint main(void)\n{\n    int i;\n    for(i=1; i<45; i++){\n        printf(\"%d = %d\\n\", i, fibonacci(i));\n    }\n    return 0;\n}\n\nint fibonacci(int n)\n{\n    int i, a, b, next;\n    if(n <= 2){\n        return 1;\n    }\n    a = 1; b = 1;\n    for(i=3; i<=n; i++){    //因为 fib(n) = fib(n-1) + fib(n-2)，所以i从3开始。\n        next = a + b;\n        a = b;\n        b = next;\n    }\n    return b;\n}\n\n//Recursive Fibonacci Sequence\nint fibon(int n)\n{\n    if(n == 1) return 1;\n    if(n == 2) return 1;    //n=1或2时，还无法递归。\n    return( fibon(n-1)+fibon(n-2));\n}\n
===================================================================
--- ../chap5/Recursion/fibonacci.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/fibonacci.c	(date 1615245742221)
@@ -3,7 +3,7 @@
    斐波那契数列：
         fib(1) is 1
         fib(2) is 1
-        fib(n) is fib(n-1)+fib(n-2)
+        fib(n) is fib(n-1)+fib(n-2)  对斐波那契数列的第n个数（当n>2）的定义。
         1,1,2,3,5,8,13,21, ... 每个数是前两位数字的和。
  */
 #include <stdio.h>
Index: ../chap9/3nd Hashing/Realloc/specific.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n#define HASHTYPE \"Realloc\"\n#define FIXEDSIZE 17\n#define SCALEFACTOR 2\n\nstruct dataframe {\n    void* key;\n    void* data;\n};\ntypedef struct dataframe dataframe;\n\nstruct assoc {\n/* Underlying array */\n    dataframe* hashTable;\n    int keySize;\n    unsigned int size;\n    unsigned int capacity;\n};\ntypedef struct assoc assoc;\n\n\n\n
===================================================================
--- ../chap9/3nd Hashing/Realloc/specific.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ Hashing/Cuckoo/specific.h	(date 1615245742362)
@@ -1,7 +1,8 @@
 
-#define HASHTYPE "Realloc"
+#define HASHTYPE "Coukoo"
 #define FIXEDSIZE 17
 #define SCALEFACTOR 2
+#define NUM_HASHTABLE 2
 
 struct dataframe {
     void* key;
@@ -11,9 +12,9 @@
 
 struct assoc {
 /* Underlying array */
-    dataframe* hashTable;
+    dataframe* hashTable[NUM_HASHTABLE];
     int keySize;
-    unsigned int size;
+    unsigned int size[NUM_HASHTABLE];
     unsigned int capacity;
 };
 typedef struct assoc assoc;
Index: Hashing/Cuckoo/cuckoo.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Hashing/Cuckoo/cuckoo.c	(date 1615245742360)
+++ Hashing/Cuckoo/cuckoo.c	(date 1615245742360)
@@ -0,0 +1,223 @@
+#include "specific.h"
+#include "../assoc.h"
+#include <math.h>
+/* Seed for BKDR Hash, can be 31 131 1313 13131 131313 etc.. */
+#define SEED 131
+typedef enum bool{false,true} bool;
+
+unsigned int Hash1(assoc* a, void* key);
+unsigned int Hash2(assoc* a, void* key);
+assoc* assoc_realloc(assoc* old);
+int getPrime(assoc* a);
+bool isPrime(int n);
+bool key_isSame(assoc* a,void* key,unsigned int label,unsigned int index);
+
+assoc* assoc_init(int keysize)
+{
+    assoc* a;
+    if(keysize<0){
+        on_error("Invalid key size");
+    }
+    a = (assoc*) ncalloc(sizeof(assoc), 1);
+    a->hashTable[0] = (dataframe*) ncalloc(sizeof(dataframe), FIXEDSIZE);
+    a->hashTable[1] = (dataframe*) ncalloc(sizeof(dataframe), FIXEDSIZE);
+    a->size[0] = a->size[1] = 0;
+    a->capacity = FIXEDSIZE;
+    a->keySize = keysize;
+    return a;
+}
+
+void assoc_insert(assoc** a, void* key, void* data)
+{
+    unsigned int index, threshold, cntColl, label, i;
+    void *oldKey, *oldData, *k, *d;
+    k = key, d = data;
+    cntColl = 0, label = 0;
+    threshold = (unsigned int) log((*a)->capacity)/log(2);
+
+    if(*a == NULL || key == NULL){
+        return;
+    }
+    index = Hash1(*a, key);
+    /* Cell of t0 is empty, do the insertion */
+    if((*a)->hashTable[label][index].key == NULL) {
+        (*a)->hashTable[label][index].key = key;
+        (*a)->hashTable[label][index].data = data;
+        (*a)->size[label] = (*a)->size[label] + 1;
+    }
+    else{
+    /* Cell of t0 is occupied */
+        while ((*a)->hashTable[label][index].key != NULL)
+        {   /* Same key existed, update data only */
+            if (key_isSame(*a, k, label, index)) {
+                (*a)->hashTable[label][index].data = d;
+                return;
+            }
+            /* Collision, kick off the existed key */
+            else {
+                cntColl++;
+                oldKey = (*a)->hashTable[label][index].key;
+                oldData = (*a)->hashTable[label][index].data;
+                (*a)->hashTable[label][index].key = k;
+                (*a)->hashTable[label][index].data = d;
+                /* Kicked keys will bounce between hashTable t0 and t1 */
+                label = cntColl % NUM_HASHTABLE;
+                /* When collision times reaches the threshold, realloc more space */
+                for(i = 0; i < NUM_HASHTABLE; i++){
+                    if (cntColl >= threshold || (*a)->size[i] >= (*a)->capacity) {
+                        *a = assoc_realloc(*a);
+                        cntColl = 0;
+                    }
+                }
+                /* Rehash the kicked key */
+                k = oldKey;
+                d = oldData;
+                index = (!label) ? Hash1(*a, k) : Hash2(*a, k);
+            }
+        }
+        /*  Empty cell is found by the latest kicked key */
+        (*a)->hashTable[label][index].key = k;
+        (*a)->hashTable[label][index].data = d;
+        (*a)->size[label] = (*a)->size[label] + 1;
+    }
+}
+
+unsigned int assoc_count(assoc* a)
+{
+    unsigned int i, s;
+    s = 0;
+    if(a == NULL){
+        return 0;
+    }
+    for(i = 0; i < NUM_HASHTABLE; i++){
+        s += a->size[i];
+    }
+    return s;
+}
+
+void* assoc_lookup(assoc* a, void* key)
+{
+    unsigned int index, i;
+    if(key == NULL){
+        printf("Invalid key\n");
+        return NULL;
+    }
+    if(assoc_count(a) == 0){
+        printf("Empty dictionary\n");
+        return NULL;
+    }
+    for(i = 0; i < NUM_HASHTABLE; i++) {
+        index = (!i) ? Hash1(a,key) : Hash2(a,key);
+        if(a->hashTable[i][index].key != NULL) {
+            if (key_isSame(a, key, i, index)) {
+                return a->hashTable[i][index].data;
+            }
+        }
+    }
+    return NULL;
+}
+
+void assoc_free(assoc* a)
+{
+    int i;
+    for(i = 0; i < NUM_HASHTABLE; i++) {
+        free(a->hashTable[i]);
+    }
+    free(a);
+}
+
+/*---------------Private Function---------------*/
+/* BKDR Hash function */
+unsigned int Hash1(assoc* a, void* key)
+{
+    unsigned int hash = 0;
+    char* p=key;
+    int i=0;
+    while( i++ < a->keySize || (a->keySize==0 && *p!='\0')){
+        hash = hash * SEED + (*p++);
+    }
+    return (hash % a->capacity);
+}
+
+/* AP Hash function  */
+unsigned int Hash2(assoc* a, void* key)
+{
+    unsigned int hash = 0;
+    char* p=key;
+    int i=0;
+    while( i++ < a->keySize || (a->keySize==0 && *p!='\0')){
+        if ((i & 1) == 0)
+        {
+            hash ^= ((hash << 7) ^ (*p++) ^ (hash >> 3));
+        }
+        else
+        {
+            hash ^= (~((hash << 11) ^ (*p++) ^ (hash >> 5)));
+        }
+    }
+    return (hash % a->capacity);
+}
+
+assoc* assoc_realloc(assoc* old)
+{
+    unsigned int i,j;
+    assoc* new;
+    unsigned int newCAP = getPrime(old);
+    new = (assoc*) ncalloc(sizeof(assoc), 1);
+    new->hashTable[0]= (dataframe*) ncalloc(sizeof(dataframe), newCAP);
+    new->hashTable[1]= (dataframe*) ncalloc(sizeof(dataframe), newCAP);
+    new->size[0] = new->size[1] = 0;
+    new->keySize = old->keySize;
+    new->capacity = newCAP;
+    /* Rehash */
+    for (j = 0; j < NUM_HASHTABLE; j++) {
+        for(i = 0; i < old->capacity; i++) {
+            if (assoc_count(new) < assoc_count(old)) {
+                assoc_insert(&new, old->hashTable[j][i].key, old->hashTable[j][i].data);
+            }
+        }
+    }
+    assoc_free(old);
+    return new;
+}
+
+bool key_isSame(assoc* a, void* key, unsigned int label, unsigned int index)
+{
+    if(a->keySize == 0){
+        if(!strcmp(a->hashTable[label][index].key, key)){
+            return true;
+        }
+    }else{
+        if(!memcmp(a->hashTable[label][index].key, key, a->keySize)){
+            return true;
+        }
+    }
+    return false;
+}
+
+bool isPrime(int n)
+{
+    int i;
+    if(n == 2){
+        return true;
+    }
+    if(n < 2 || n % 2 == 0){
+        return false;
+    }
+    for (i = 3; i * i <= n; i+=2) {
+        if (n % i == 0) {
+            return false;
+        }
+    }
+    return true;
+}
+
+int getPrime(assoc* a)
+{
+    int num;
+    num = a->capacity * SCALEFACTOR;
+    while(!isPrime(num)){
+        num++;
+    }
+    return num;
+}
Index: Turtle/break-samples/testing
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Turtle/break-samples/testing	(date 1615245742347)
+++ Turtle/break-samples/testing	(date 1615245742347)
@@ -0,0 +1,13 @@
+2.White-box testing
+
+    This program uses a testing framework called "MinUnit" to conduct white box testing.
+    The framework test parser functions by comparing the output of unit functions with the expected ones automatically.
+    Use different samples of .ttl programs in break-samples directory to test if a specific function is stable.
+
+    A MinUnit test case is a minimal unit test framework for C.
+    It is just a function that returns 0 (null) if the tests pass.
+    If the test fails, the function should return a string describing the failing test.
+    The mu_assert is simply a macro that returns a string if the expression passed to it is false.
+    The mu_runtest macro calls another test case and returns if that test case fails.
+
+    ( MinUnit's reference: http://www.jera.com/techinfo/jtns/jtn002.html#License )
Index: ../chap9/Hashing/Separate_Chaining.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2020/12/12.\n//\n\n
===================================================================
--- ../chap9/Hashing/Separate_Chaining.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap9/Hashing/Separate_Chaining.c	(date 1615245742228)
@@ -1,4 +1,22 @@
-//
-// Created by Karine Liang on 2020/12/12.
-//
+/* 独立链条法/拉链法。  区别于开放地址法（线性指针法linear probing、双哈希法double hashing）
+Modified Bernstein hashing
+5381 & 33 are magic numbers required by the algorithm
+*/
+
+/* Q：为什么Double-hashing的冲突解决发，需要哈希表的size要是质数？
+ * A：因为解决冲突要进行指针移动时，如果size是偶数(如16)，那哈希函数mod出来的如果是一个偶数，
+ * 比如2，在偶数格子里2格一步地移动（如始落在6，那只走0-2-4-6-8-10-12-14），首尾循环时仍走已走过的格子，无法Touch哈希表所有格子，所以是低效的。*/
+
+int hash(unsigned int sz, char *s)
+{
+    unsigned long hash = 5381;
+    int c;
+    while((c = (*s++))){
+        hash = 33 * hash ˆ c;
+    }
+    return (int)(hash%sz);
+}
+
+/*布谷鸟哈希--当两个哈希表之间的bounce>=log2^size时，如例子size=16,当弹跳4次时，防止其陷入死循环，
+ * 就需要做 Rehash(改表的哈希函数)或者做 Resize（但需要把前半部分复制过去，很贵）。*/
 
Index: Hashing/Realloc/realloc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Hashing/Realloc/realloc.c	(date 1615245742319)
+++ Hashing/Realloc/realloc.c	(date 1615245742319)
@@ -0,0 +1,144 @@
+#include "specific.h"
+#include "../assoc.h"
+
+/* Seed for BKDR Hash, can be 31 131 1313 13131 131313 etc.. */
+#define SEED 131
+#define LOAD_FACTOR 0.7
+typedef enum bool{false,true} bool;
+
+unsigned int Hash_BKDR(assoc* a, void* key);
+unsigned int Rehash_linear(assoc* a, unsigned int index);
+bool key_isSame(assoc* a, void* key, unsigned int index);
+assoc* assoc_realloc(assoc* old);
+
+assoc* assoc_init(int keysize)
+{
+    assoc* a;
+    if(keysize<0){
+        on_error("Invalid key size");
+    }
+    a = (assoc*) ncalloc(sizeof(assoc), 1);
+    a->hashTable = (dataframe*) ncalloc(sizeof(dataframe), FIXEDSIZE);
+    a->size = 0;
+    a->capacity = FIXEDSIZE;
+    a->keySize = keysize;
+    return a;
+}
+
+void assoc_insert(assoc** a, void* key, void* data)
+{
+    unsigned int index;
+    if(*a == NULL || key == NULL){
+        return;
+    }
+    index = Hash_BKDR(*a,key);
+    /* Check whether the cell is occupied */
+    while((*a)->hashTable[index].key != NULL){
+            /* Same key existed, update data only */
+        if (key_isSame(*a, key, index)){
+            (*a)->hashTable[index].data = data;
+            return;
+        }
+        else{
+            /* Collision, rehash it until an empty cell is found */
+            index = Rehash_linear(*a,index);
+        }
+    }
+    /* Empty cell is found, insert key/data pair */
+    (*a)->hashTable[index].key = key;
+    (*a)->hashTable[index].data = data;
+    (*a)->size = (*a)->size + 1;
+    /* realloc more space when hashTable is too small */
+    if((*a)->size >= LOAD_FACTOR * (*a)->capacity){
+        *a = assoc_realloc(*a);
+    }
+}
+
+unsigned int assoc_count(assoc* a)
+{
+    if(a==NULL){
+        return 0;
+    }
+    return a->size;
+}
+
+void* assoc_lookup(assoc* a, void* key)
+{
+    unsigned int index;
+    if(key == NULL){
+        printf("Invalid key\n");
+        return NULL;
+    }
+    if(assoc_count(a)==0){
+        printf("Empty dictionary\n");
+        return NULL;
+    }
+    index = Hash_BKDR(a,key);
+    while(a->hashTable[index].key != NULL){
+        if(key_isSame(a, key, index)) {
+            return a->hashTable[index].data;
+        }else{
+            index = Rehash_linear(a,index);
+        }
+    }
+    return NULL;
+}
+
+void assoc_free(assoc* a)
+{
+    free(a->hashTable);
+    free(a);
+}
+
+/*---------------Private Function---------------*/
+unsigned int Hash_BKDR(assoc* a, void* key)
+{
+    unsigned int hash = 0;
+    char* p=key;
+    int i=0;
+    while( i++ < a->keySize || (a->keySize==0 && *p!='\0')){
+        hash = hash * SEED + (*p++);
+    }
+    return (hash % a->capacity);
+}
+
+unsigned int Rehash_linear(assoc* a, unsigned int index)
+{
+    index += 1;
+    return index % a->capacity;
+}
+
+bool key_isSame(assoc* a, void* key, unsigned int index)
+{
+    if(a->keySize == 0){
+        if(!strcmp(a->hashTable[index].key, key)){
+            return true;
+        }
+    }
+    else{
+        if(!memcmp(a->hashTable[index].key, key, a->keySize)){
+            return true;
+        }
+    }
+    return false;
+}
+
+assoc* assoc_realloc(assoc* old)
+{
+    unsigned int i;
+    assoc* new;
+    /* Resize */
+    new = (assoc*) ncalloc(sizeof(assoc), 1);
+    new->hashTable = (dataframe*) ncalloc(sizeof(dataframe), old->capacity * SCALEFACTOR);
+    new->size = 0;
+    new->keySize = old->keySize;
+    new->capacity = old->capacity * SCALEFACTOR;
+    /* Rehash */
+    for(i = 0; i < old->capacity; i++) {
+        if (new->size < old->size) {
+            assoc_insert(&new, old->hashTable[i].key, old->hashTable[i].data);
+        }
+    }
+    assoc_free(old);
+    return new;
+}
Index: ../chap7/ADT:Stack/linked.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"specific_linked=dynamic.h.h\"\n#include \"../stack.h\"\n\n#define DOTFILE 5000\n\nstack* stack_init(void)\n{\n    stack* s = (stack*) ncalloc(sizeof(stack), 1);/* 只要是linked，初始定义时只需要给stack/coll分配一个空间即可。也不需要初始化size */\n    s->size=0;\n    return s;\n}\n\nvoid stack_push(stack* s, datatype d)\n{\n    dataframe* f;\n    if(s){\n        f = ncalloc(sizeof(dataframe), 1);/* linked是在插入时，才分配一格dataframe的空间，无需赋初值，直接把数据存到新建的格子中。\n                                           * 但要连接链条：原开头连到新格子的下一格：f->next = s->start(注意开头在链条的最右侧！)、\n                                           * 新格子地址成为新开头、修改实时size大小。*/\n        f->i = d;\n        f->next = s->start;\n        s->start = f;\n        s->size = s->size + 1;\n    }\n}\n\nbool stack_pop(stack* s, datatype* d)\n{\n    dataframe* f;\n    if((s==NULL) || (s->start==NULL)){/*和realloc的stack不同在于，linked检验开头是否为空指针，realloc检验size是否为<=0*/\n        return false;\n    }\n    f = s->start->next;/* 要去掉开头 所以把开头中的第二格地址保存到了临时变量f中*/\n                       /* 与linked coll不同，没法*/\n    *d = s->start->i;/* 与linked coll不同的是,coll是查找到d后，做跨格链接，不再利用d；这里stack不做查找，也只能取开头的数据d，而且d还要再利用,所以传入的d是指针，直接通过指针传回d*/\n    free(s->start);/* 释放所取出的开头格子*/\n    s->start = f;/* 之前临时变量存的第二格成为新开头（与stack realloc不同，realloc无需重连接，取出转存d+修改size就行，而linked要重连接）*/\n    s->size = s->size - 1;/* 取出后记得修改size*/\n    return true;\n}\n\nbool stack_peek(stack* s, datatype* d)\n{\n    if((s==NULL) || (s->start==NULL)){/*和realloc的stack不同在于，linked检验开头是否为空指针，realloc检验size是否为<=0*/\n        return false;\n    }\n    *d = s->start->i;\n    return true;\n}\n\nvoid stack_tostring(stack* s, char* str)\n{\n    dataframe *p;/*linked类型的，函数内部一般需要定义一个遍历指针（如转字符串的p）,或临时指针（如插入、取出和释放时的f，以及coll linked查找时的f）*/\n    char tmp[ELEMSIZE];\n    str[0] = '\\0';\n    if((s==NULL) || (s->size <1)){\n        return;\n    }\n    p = s->start;\n    while(p){/*遍历linked指针，用 p = s->start; while(p){ ....; p = p->next;} 来不断向下将指针移位。*/\n        sprintf(tmp, FORMATSTR, p->i);\n        strcat(str, tmp);\n        strcat(str, \"|\");\n        p = p->next;\n    }\n    str[strlen(str)-1] = '\\0';\n}\n\nbool stack_free(stack* s)/*同linked Coll。*/\n{\n    if(s){\n        dataframe* tmp;\n        dataframe* p = s->start;\n        while(p!=NULL){\n            tmp = p->next;\n            free(p);\n            p = tmp;\n        }\n        free(s);\n    }\n    return true;\n}\n\n
===================================================================
--- ../chap7/ADT:Stack/linked.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap7/ADT:Stack/linked.c	(date 1615245742240)
@@ -1,24 +1,24 @@
 #include "specific_linked=dynamic.h.h"
-#include "../stack.h"
+#include "stack.h"
 
-#define DOTFILE 5000
+#define DOTFILE 5000    /*这是啥？？*/
 
 stack* stack_init(void)
 {
-    stack* s = (stack*) ncalloc(sizeof(stack), 1);/* 只要是linked，初始定义时只需要给stack/coll分配一个空间即可。也不需要初始化size */
-    s->size=0;
+    stack* s = (stack*) ncalloc(sizeof(stack), 1);
+    s->size = 0;
     return s;
 }
 
 void stack_push(stack* s, datatype d)
 {
-    dataframe* f;
+    dataframe* f;   /*新插入数据，创建一个新数据格，数据存入后再用链条连上。*/
     if(s){
         f = ncalloc(sizeof(dataframe), 1);/* linked是在插入时，才分配一格dataframe的空间，无需赋初值，直接把数据存到新建的格子中。
                                            * 但要连接链条：原开头连到新格子的下一格：f->next = s->start(注意开头在链条的最右侧！)、
                                            * 新格子地址成为新开头、修改实时size大小。*/
         f->i = d;
-        f->next = s->start;
+        f->next = s->start; /* start保持更新指向顶层数据格，旧的数据格始终在下面/底层。那初始化之后的start是空指针！因为用calloc创建的新栈。*/
         s->start = f;
         s->size = s->size + 1;
     }
@@ -27,15 +27,14 @@
 bool stack_pop(stack* s, datatype* d)
 {
     dataframe* f;
-    if((s==NULL) || (s->start==NULL)){/*和realloc的stack不同在于，linked检验开头是否为空指针，realloc检验size是否为<=0*/
+    if((s == NULL) || (s->start == NULL)){/*先检验栈是否存在，再检验数据是否存在。linked检验：开头是否为空指针（无数据可取出），realloc检验：size是否为<=0 */
         return false;
     }
-    f = s->start->next;/* 要去掉开头 所以把开头中的第二格地址保存到了临时变量f中*/
-                       /* 与linked coll不同，没法*/
-    *d = s->start->i;/* 与linked coll不同的是,coll是查找到d后，做跨格链接，不再利用d；这里stack不做查找，也只能取开头的数据d，而且d还要再利用,所以传入的d是指针，直接通过指针传回d*/
-    free(s->start);/* 释放所取出的开头格子*/
-    s->start = f;/* 之前临时变量存的第二格成为新开头（与stack realloc不同，realloc无需重连接，取出转存d+修改size就行，而linked要重连接）*/
-    s->size = s->size - 1;/* 取出后记得修改size*/
+    f = s->start->next;/* 要去掉开头第一格。所以先把第一格中的第二格地址给f，也就是用f指向第二格，防止该地址丢失*/
+    *d = s->start->i;/* stack用d变量接走取出第一格的数据，而且d还要再利用,所以直接通过传d指针直接改变值，就无需return来转存。*/
+    free(s->start);/* 数据和下一个地址都备份好了，就释放要取出的开头格子*/
+    s->start = f;/* 之前备份的第二格f，现在成为了新开头（与stack realloc不同，realloc无需重连接，取出转存d+修改size就行，而linked要重连接）*/
+    s->size = s->size - 1;/* 取出后记得修改栈的size*/
     return true;
 }
 
@@ -71,13 +70,12 @@
     if(s){
         dataframe* tmp;
         dataframe* p = s->start;
-        while(p!=NULL){
-            tmp = p->next;
+        while(p != NULL){
+            tmp = p->next;  /*就是说p非空时，p->next可能为空（到最底部的数据格了）*/
             free(p);
             p = tmp;
         }
         free(s);
     }
     return true;
-}
-
+}
\ No newline at end of file
Index: ../chap7/ADT:Stack/specific_linked=dynamic.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>typedef int datatype;\n#define FORMATSTR \"%d\"\n#define ELEMSIZE 20\n\n#define STACKTYPE \"Linked\"\n/* linked 和 realloc对比不同点：首先是define处无需 FIXEDSIZE 和 SCALEFACOR，\n * 因为linked无需担心装不下而要再分配内存空间的问题。因为只存一个指针，该指针指向别的地方套娃*/\n/* 第二个不同点，在于linked list需要在stack里再定义一个struct，也就是dataframe，因为它的数据和下一格地址指针是伴随关系，要以pair的方式存储。*/\n/* 大的表stack,coll..其结构体必须伴随size，用于判断是否为空以及遍历等。有无capacity根据种类而定。*/\n\nstruct dataframe {\n    datatype i;\n    struct dataframe* next;\n};\ntypedef struct dataframe dataframe;\n\nstruct stack {\n/* Underlying array */\n    dataframe* start;\n    int size;\n};
===================================================================
--- ../chap7/ADT:Stack/specific_linked=dynamic.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap7/ADT:Stack/specific_linked=dynamic.h	(date 1615245742251)
@@ -18,4 +18,5 @@
 /* Underlying array */
     dataframe* start;
     int size;
-};
\ No newline at end of file
+};
+typedef struct stack stack;
\ No newline at end of file
Index: ../chap6/ADTs: Collection/coll.h
===================================================================
--- ../chap6/ADTs: Collection/coll.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap6/ADTs: Collection/coll.h	(date 1615245742270)
@@ -1,0 +1,18 @@
+#include "../General/general.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+typedef enum bool{false,true} bool;
+/* Create an empty coll */
+coll* coll_init(void);
+/* Add element onto top */
+void coll_add(coll* c, datatype i);
+/* Take element out */
+bool coll_remove(coll* c, datatype d);
+/* Does this exist ? */
+bool coll_isin(coll* c, datatype i);
+/* Return size of coll */
+int coll_size(coll* c);
+/* Clears all space used */
+bool coll_free(coll* c);
Index: ../chap6/ADTs: Collection/specific_Linked List.h
===================================================================
--- ../chap6/ADTs: Collection/specific_Linked List.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap6/ADTs: Collection/specific_Linked List.h	(date 1615245742276)
@@ -1,0 +1,15 @@
+typedef int datatype;
+#define COLLTYPE "Linked"
+
+struct dataframe {  /*表中底层数组的每一格内不再是单纯的数据——而是数据 + 指向下一格子的指针；这样我的表只用存这个数组的开头，即可找到所有数据。*/
+    datatype i;
+    struct dataframe* next;
+};
+typedef struct dataframe dataframe;
+
+struct coll {
+/* Underlying array */
+    dataframe* start;
+    int size;
+};
+typedef struct coll coll;
\ No newline at end of file
Index: ../chap6/ADTs: Collection/specific_Dynamic Array.h
===================================================================
--- ../chap6/ADTs: Collection/specific_Dynamic Array.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap6/ADTs: Collection/specific_Dynamic Array.h	(date 1615245742282)
@@ -1,0 +1,11 @@
+typedef int datatype;
+#define COLLTYPE "Realloc"
+#define FIXEDSIZE 16
+#define SCALEFACTOR 2
+struct coll {
+/* Underlying array */
+    datatype* a;/* a变成了指针，因为要动态分配内存给数组a[]所以定义成指针 */
+    int size;
+    int capacity;/* 多了一个容量，用于根据数组大小变化的需要，随时通过realloc扩大数组大小 */
+};
+typedef struct coll coll;
\ No newline at end of file
Index: ../chap6/ADTs: Collection/specific_Fixed Array.h
===================================================================
--- ../chap6/ADTs: Collection/specific_Fixed Array.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap6/ADTs: Collection/specific_Fixed Array.h	(date 1615245742288)
@@ -1,0 +1,10 @@
+typedef int datatype;
+#define COLLTYPE "Fixed"
+#define FIXEDSIZE 5000
+struct coll {
+/* Underlying array */
+    datatype a[FIXEDSIZE];
+    int size;   /* size 可以实时跟踪表格创建、数据插入、数据移出等对表格进行的修改操作*/
+};
+typedef struct coll coll;
+/* 结构体里的a[]是底层数组，相当于一张表格，而size则相当于表头里的细小信息。 */
Index: ../chap7/ADT:Stack/realloc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"specific_realloc.h\"\n#include \"stack.h\"\n#define DOTFILE 5000\n/* Some implementations would allow you to pass\na hint about the initial size of the stack */\nstack* stack_init(void)\n{\n    /*只要是realloc的动态分配数组，开头就先要分配大的coll/stack的空间，再分配底层数组a[]的空间，然后依次对大空间里的size,capacity赋初值0、FS*/\n    stack *s = (stack*) ncalloc(sizeof(stack), 1);\n    s->a = (datatype*) ncalloc(sizeof(datatype),FIXEDSIZE);\n    s->size = 0;\n    s->capacity= FIXEDSIZE;\n    return s;\n}\n\n/* push = add */\nvoid stack_push(stack* s, datatype d)\n{\n    if(s==NULL){\n        return;\n    }\n    s->a[s->size] = d;/*底层数组不是结构里面没有size，这里是为了把数据存到底层数组中与存入前\"size\"对应的格子中去*/\n    s->size = s->size + 1;\n    if(s->size >= s->capacity){/*判断满了--realloc新指针给表/stack--修改capacity--若realloc失败返回NULL要报错 */\n        s->a = (datatype*) realloc(s->a,sizeof(datatype)*s->capacity*SCALEFACTOR);\n        s->capacity = s->capacity*SCALEFACTOR;\n        if(s->a == NULL){\n            on_error(\"Stack overflow\");\n        }\n    }\n}\n\n/* pop = delete */\nbool stack_pop(stack* s, datatype* d)\n{\n    if((s == NULL) || (s->size < 1)){/* 每个查找或修改操作前，都要检查s是否为空指针。\n                                      * 这里还检查了size是否小于1（即为0），这样就没有可以取出来的数据，取出失败。*/\n        return false;\n    }\n    s->size = s->size - 1;\n    *d = s->a[s->size];/* 取出：先修改size（因为目前size是用来存下一个新数据的）再把改后size对应的数据，存到传过来的数据指针中去。\n                           * 这样做完一次pop后，向pop传入的数据变量更新为取出的数值。*/\n    return true;\n}\n\nbool stack_peek(stack* s, datatype* d)\n{\n    if((s==NULL) || (s->size <= 0)){ /* size<1 等同于size<=0，也就是栈内无数据，查找最上面的数据失败。*/\n/* Stack is Empty */\n        return false;\n    }\n    *d = s->a[s->size-1]; /* 非空栈，对比pop就是不做减少size的操作，直接查询取得size-1对应格子的值，修改*d。*/\n    return true;\n}\n\n/* 转换为字符串形式主要是为了方便测试。*/\nvoid stack_tostring(stack* s, char* str)\n{\n    int i;\n    char tmp[ELEMSIZE];/* ELMS是将栈内每格数据取出来后存放空间的初始长度，要大于初始栈长FIXEDSIZE */\n    str[0] = '\\0';/* 将存放stack内数据的字符串数组str[]，初始化为空。？这样下面做附加操作，那开头结尾都是终止符了？ */\n    if((s==NULL) || (s->size <1)){/* 若为空栈，没法转字符串。*/\n        return;\n    }\n    /* ！先用sprintf把stack里的数据用临时字符串temp接出来，再用strcat把temp里接出来的字符串接到目的地字符串str中去。*/\n    for(i=s->size-1; i>=0; i--){/* 因为从栈的顶部取出值--即栈struct内底层数组的尾部。所以循环变量要--，倒着来计数取出。*/\n        sprintf(tmp, FORMATSTR, s->a[i]);/*sprintf 根据输出样式、输出来源，将输出结果输入到一个字符串中，利于创建一个作为中间产物的字符串。*/\n        strcat(str, tmp);/* 注意这里strcat不是复制tmp到str，而是将tmp复制到str的尾巴去，相当于\"附加\"*/\n        strcat(str, \"|\");/* 每往str格子输入一个数据，就紧接着\"附加\"一个分隔符 */\n    }\n    str[strlen(str)-1] = '\\0';/*strlen得到的长度，是'\\0'之前的长度。这里改len(str)-1为终止符也没关系，因为根据上面赋值，最后一个结尾的字符是\"｜\"分隔符。*/\n}\n\nbool stack_free(stack* s)\n{\n    if (s == NULL) {\n        return true;\n    }\n    free(s->a);/*挨个释放，从struct内部的底层数组a，到释放为struct栈表创建的空间*/\n    free(s);\n    return true;\n}\n
===================================================================
--- ../chap7/ADT:Stack/realloc.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap7/ADT:Stack/realloc.c	(date 1615245742293)
@@ -58,13 +58,13 @@
 {
     int i;
     char tmp[ELEMSIZE];/* ELMS是将栈内每格数据取出来后存放空间的初始长度，要大于初始栈长FIXEDSIZE */
-    str[0] = '\0';/* 将存放stack内数据的字符串数组str[]，初始化为空。？这样下面做附加操作，那开头结尾都是终止符了？ */
+    str[0] = '\0';/* 将存放stack内数据的字符串数组str[]，初始化为空。这样下面做附加接入操作，开头不会是\0吗？ */
     if((s==NULL) || (s->size <1)){/* 若为空栈，没法转字符串。*/
         return;
     }
     /* ！先用sprintf把stack里的数据用临时字符串temp接出来，再用strcat把temp里接出来的字符串接到目的地字符串str中去。*/
-    for(i=s->size-1; i>=0; i--){/* 因为从栈的顶部取出值--即栈struct内底层数组的尾部。所以循环变量要--，倒着来计数取出。*/
-        sprintf(tmp, FORMATSTR, s->a[i]);/*sprintf 根据输出样式、输出来源，将输出结果输入到一个字符串中，利于创建一个作为中间产物的字符串。*/
+    for(i=s->size-1; i>=0; i--){/* 因为从栈的顶部取出值--即栈struct内底层数组的尾部（后进先出）。所以循环变量要--，倒着来计数取出。*/
+        sprintf(tmp, FORMATSTR, s->a[i]);/*sprintf 根据【输出样式】、输出来源，创建并将输出结果输入到 作为中间产物的字符串数组tmp中。*/
         strcat(str, tmp);/* 注意这里strcat不是复制tmp到str，而是将tmp复制到str的尾巴去，相当于"附加"*/
         strcat(str, "|");/* 每往str格子输入一个数据，就紧接着"附加"一个分隔符 */
     }
@@ -76,7 +76,7 @@
     if (s == NULL) {
         return true;
     }
-    free(s->a);/*挨个释放，从struct内部的底层数组a，到释放为struct栈表创建的空间*/
+    free(s->a);/*挨个释放，从struct内部的底层数组a，到释放为整个struct栈表创建的空间*/
     free(s);
     return true;
 }
Index: ../chap7/ADT:Stack/stack.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"../General/general.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n\ntypedef enum bool{false,true} bool;\n\n/* Create an empty stack */\nstack* stack_init(void);\n/* Add element to top */\nvoid stack_push(stack* s, datatype i);\n/* Take element from top */\nbool stack_pop(stack* s, datatype* d);\n/* Clears all space used */\nbool stack_free(stack* s);\n/* Optional? */\n/* Copy top element into d (but don’t pop it) */\nbool stack_peek(stack*s, datatype* d);\n/* Make a string version for testing etc. */\nvoid stack_tostring(stack*, char* str);
===================================================================
--- ../chap7/ADT:Stack/stack.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap7/ADT:Stack/stack.h	(date 1615245742297)
@@ -1,4 +1,4 @@
-#include "../General/general.h"
+#include "..//General/general.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <assert.h>
Index: ../chap6/ADTs: Collection/Using_coll.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*该程序为测试main函数，ADT.c为不同种类Coll的包含功能函数模块的程序，编译时一起编译：3个.c，3个.h */\n\n#include \"specific_Fixed Array.h\"/* 表 & 格结构体定义，数据类型定义，该类coll所用方案种类 */\n#include \"coll.h\"/* 该类coll对应的各种建表、增、减、查找、释放功能模块 */\n\nint main(void)\n{\n    coll* c;\n    printf(\"Please type some numbers :\");\n    c = coll_init();\n    while(scanf(\"%d\", &i) == 1){\n        col_add(c, i);\n    }\n/* Do print etc. */\n    coll_free(c);\n    return 0;\n}\n
===================================================================
--- ../chap6/ADTs: Collection/Using_coll.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap6/ADTs: Collection/Using_coll.c	(date 1615245742304)
@@ -9,7 +9,7 @@
     printf("Please type some numbers :");
     c = coll_init();
     while(scanf("%d", &i) == 1){
-        col_add(c, i);
+        coll_add(c, i);
     }
 /* Do print etc. */
     coll_free(c);
Index: ../chap6/ADTs: Collection/realloc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n#include \"specific_Dynamic Array.h\"\n#include \"coll.h\"\n\n/*----------ollection：ADT数据结构中，固定数组和动态数组的主要区别在于：结构体的定义、表格初始化、表格插入功能上--------*/\ncoll* coll_init(void)\n{\n    coll* c = (coll*) ncalloc(sizeof(coll), 1);\n    c->a = (datatype*) ncalloc(sizeof(datatype),FIXEDSIZE);\n    c->size = 0;\n    c->capacity= FIXEDSIZE;/* capacity是目前数组容量大小，size是数组现有元素个数（实时大小），FS是初始化数组容量*/\n    return c;\n}\nvoid coll_add(coll* c, datatype d)\n{\n    if(c){\n        c->a[c->size] = d;\n        c->size = c->size + 1;\n        if(c->size >= c->capacity){/* 一旦装满，开始realloc一个两倍大小的新空间。*/\n            c->a = (datatype*) realloc(c->a,sizeof(d)*c->capacity*SCALEFACTOR);/* Realloc会把创建一个新的空间，把旧空间指向的数据都复制过来，并free掉旧空间。 */\n            if(c->a == NULL){\n                on_error(\"Collection overflow\");\n            c->capacity = c->capacity*SCALEFACTOR;/* 每次将容量扩大一倍，这样是逐步增加。若用指针扩大可能创建过多而实际需要只多出一点点。*/\n        }\n    }\n}\n/*------------以下函数基本不变------------*/\nint coll_size(coll* c)\n{\n    if(c==NULL){\n        return 0;\n    }\n    return c->size;\n}\n\nbool coll_isin(coll* c, datatype d)\n{\n    int i;\n    for(i=0; i<coll_size(c); i++){\n        if(c->a[i] == d){\n            return true;\n        }\n    }\n    return false;\n}\n\nbool coll_remove(coll* c, datatype d)\n{\n    int i,j;\n    for(i=0; i<coll_size(c); i++){\n        if(c->a[i] == d){\n            /* Shuffle end of array left one */\n            for(j=i; j<coll_size(c); j++){\n                c->a[j] = c->a[j+1];\n            }\n            c->size = c->size - 1;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool coll_free(coll* c)\n{\n    free(c);\n    return true;\n}\n
===================================================================
--- ../chap6/ADTs: Collection/realloc.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap6/ADTs: Collection/realloc.c	(date 1615245742313)
@@ -5,8 +5,8 @@
 /*----------ollection：ADT数据结构中，固定数组和动态数组的主要区别在于：结构体的定义、表格初始化、表格插入功能上--------*/
 coll* coll_init(void)
 {
-    coll* c = (coll*) ncalloc(sizeof(coll), 1);
-    c->a = (datatype*) ncalloc(sizeof(datatype),FIXEDSIZE);
+    coll* c = (coll*) ncalloc(sizeof(coll), 1);/* 建了一个struct就有一个数组：a[] */
+    c->a = (datatype*) ncalloc(sizeof(datatype),FIXEDSIZE);/* 相当于给上面的a[]明确[]里有多少格。建立一个长度为FS的字符串数组，当实际size不满足于大小后，realloc一个大小为2FS的新空间，并复制旧数据、释放旧空间 */
     c->size = 0;
     c->capacity= FIXEDSIZE;/* capacity是目前数组容量大小，size是数组现有元素个数（实时大小），FS是初始化数组容量*/
     return c;
@@ -16,10 +16,13 @@
     if(c){
         c->a[c->size] = d;
         c->size = c->size + 1;
-        if(c->size >= c->capacity){/* 一旦装满，开始realloc一个两倍大小的新空间。*/
-            c->a = (datatype*) realloc(c->a,sizeof(d)*c->capacity*SCALEFACTOR);/* Realloc会把创建一个新的空间，把旧空间指向的数据都复制过来，并free掉旧空间。 */
-            if(c->a == NULL){
+
+        /* 一旦装满，开始realloc一个两倍大小的新空间。*/
+        if(c->size >= c->capacity){
+            c->a = (datatype*) realloc(c->a,sizeof(d)*c->capacity*SCALEFACTOR);/* Realloc会创建一个新的空间，把旧空间指向的数据都复制过来，并free掉旧空间。 */
+            if(c->a == NULL) {
                 on_error("Collection overflow");
+            }
             c->capacity = c->capacity*SCALEFACTOR;/* 每次将容量扩大一倍，这样是逐步增加。若用指针扩大可能创建过多而实际需要只多出一点点。*/
         }
     }
Index: ../chap11/Parsing/Implementing Reverse Polish.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2021/1/29.\n//\n\n
===================================================================
--- ../chap11/Parsing/Implementing Reverse Polish.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap11/Parsing/Implementing Reverse Polish.c	(date 1615245742334)
@@ -1,4 +1,59 @@
-//
-// Created by Karine Liang on 2021/1/29.
-//
+#include <stdlib.h>
+#include <assert.h>
+#include <stdio.h>
+#include "../../chap7/ADT:Stack/stack.h"
+#include "../../chap7/ADT:Stack/specific_linked=dynamic.h"
+
+#define MAXINPUT 1000
+
+int main(void)
+{
+    char input[MAXINPUT];
+    stack* s;
+    datatype d, opd1, opd2;
+    s = stack_init();
+    while(fgets(input, MAXINPUT, stdin)){ /* 用fgets 从键盘获得最长长度 = MAXINPUT 的字符串，输入到新建名为"input"的字符串数组中。
+                                            * fgets 遇到空格不停止，遇到换行才停止输入。 */
+        /* If number push */
+        if(sscanf(input, FORMATSTR, &d) == 1){   /* 用sscanf，配合fgets使用。从由fgets得到的一行输入（即input这个临时的字符串数组），
+                                                * 找数字（根据%f、%d扫描数字）存到d中，同时不*/
+            stack_push(s, d);
+        }
+        else{
+            /* Must be an operator ? */
+            assert(stack_pop(s, &g2));
+            assert(stack_pop(s, &g1));
+            switch(input[0]){
+                case '+' :
+                    d = g1 + g2;
+                    break;
+                case '-' :
+                    d = g1 - g2;
+                    break;
+                case '*' :
+                    d = g1 * g2;
+                    break;
+                case '/' :
+                    d = g1 / g2;
+                    break;
+                default:
+                    fprintf(stderr, "Can’t understand ? %d\n",
+                            input[0]);
+                    exit(EXIT_FAILURE);
+            }
+            stack_push(s, d);
+        }
+    }
+    assert(stack_pop(s, &d));
+    printf("Answer = ");
+    printf(FORMATSTR, d);
+    printf("\n");
+    if(stack_peek(s, &d) == true){
+        fprintf(stderr, "Stack still had items on it ?\n");
+        exit(EXIT_FAILURE);
+    }
+    stack_free(s);
+    return 0;
+}
+
 
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(date 1615244704920)
+++ .idea/vcs.xml	(date 1615244704920)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(date 1615244704915)
+++ .idea/modules.xml	(date 1615244704915)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/assignment.iml" filepath="$PROJECT_DIR$/.idea/assignment.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/assignment.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/assignment.iml	(date 1615244704905)
+++ .idea/assignment.iml	(date 1615244704905)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="CPP_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/workspace.xml	(date 1615245887298)
+++ .idea/workspace.xml	(date 1615245887298)
@@ -0,0 +1,332 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="BranchesTreeState">
+    <expand>
+      <path>
+        <item name="ROOT" type="e8cecc67:BranchNodeDescriptor" />
+        <item name="LOCAL_ROOT" type="e8cecc67:BranchNodeDescriptor" />
+      </path>
+    </expand>
+    <select>
+      <path>
+        <item name="ROOT" type="e8cecc67:BranchNodeDescriptor" />
+        <item name="LOCAL_ROOT" type="e8cecc67:BranchNodeDescriptor" />
+        <item name="BRANCH:master" type="e8cecc67:BranchNodeDescriptor" />
+      </path>
+    </select>
+  </component>
+  <component name="CMakeRunConfigurationManager" shouldGenerate="true" shouldDeleteObsolete="true">
+    <generated />
+  </component>
+  <component name="CMakeSettings">
+    <configurations>
+      <configuration PROFILE_NAME="Debug" CONFIG_NAME="Debug" />
+    </configurations>
+  </component>
+  <component name="ChangeListManager">
+    <list default="true" id="a25fd582-e8dd-4087-a8b6-c9b0d7e21e39" name="Default Changelist" comment="">
+      <change afterPath="$PROJECT_DIR$/.idea/assignment.iml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/modules.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Hashing/Cuckoo/cuckoo.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Hashing/Realloc/realloc.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Hashing/feedback/general" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Hashing/feedback/personal" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Hashing/test3.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Hashing/testassoc.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Hashing/title/1.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Hashing/title/2.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Turtle/break-samples/testing" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Turtle/title/1.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Turtle/title/2.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Turtle/title/3.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Turtle/title/4.png" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../1st assignment forest fire/forest fire.zip" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../1st assignment forest fire/forest_ex.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../2nd/2nd.c" beforeDir="false" afterPath="$PROJECT_DIR$/../2nd/2nd.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../2nd/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/../2nd/Makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../2nd/bookcase.c" beforeDir="false" afterPath="$PROJECT_DIR$/../2nd/bookcase.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../2nd/open" beforeDir="false" afterPath="$PROJECT_DIR$/../2nd/open" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../2nd/open.c" beforeDir="false" afterPath="$PROJECT_DIR$/../2nd/open.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../2nd/open.dSYM/Contents/Resources/DWARF/open" beforeDir="false" afterPath="$PROJECT_DIR$/../2nd/open.dSYM/Contents/Resources/DWARF/open" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../2nd/test.dSYM/Contents/Resources/DWARF/test" beforeDir="false" afterPath="$PROJECT_DIR$/../2nd/test.dSYM/Contents/Resources/DWARF/test" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../CA-template.s" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle.zip" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/DATA/basic.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/DATA/basic.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/DATA/loop.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/DATA/loop.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/DATA/nested.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/DATA/nested.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/DATA/stack_testsample" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/DATA/stack_testsample" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/DATA/usevar.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/DATA/usevar.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/FormalGrammar" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/FormalGrammar" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/General/general.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/General/general.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/General/general.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/General/general.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/Point/point.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/Point/point.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/Point/point.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/Point/point.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/SDL/neillsdl2.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/SDL/neillsdl2.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/SDL/neillsdl2.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/SDL/neillsdl2.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/Stack/linked.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/Stack/linked.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/Stack/stack.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/Stack/stack.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/Varpool/varpool.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/Varpool/varpool.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/Varpool/varpool.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/Varpool/varpool.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/interp.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/interp.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/interp.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/interp.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/pars-interp.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/pars-interp.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Interp/pars-interp.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Interp/pars-interp.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Parser/parser.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Parser/parser.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Parser/parser.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Parser/parser.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Realloc/realloc.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Realloc/realloc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/Realloc/realloc.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/Realloc/realloc.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/from-1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/from-1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/from1.5.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/from1.5.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/fromAtoA.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/fromAtoA.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/fromAtoB(A&gt;B)1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/fromAtoB(A&gt;B)1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/fromAtoB(A&gt;B)2.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/fromAtoB(A&gt;B)2.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/nofrom.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/nofrom.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/nolfbrace.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/nolfbrace.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/noto.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/noto.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/novar1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/novar1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/novar2.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/novar2.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/novarnum1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/novarnum1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakDo/novarnum2.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakDo/novarnum2.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstrctlst/extra_rtbrace.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstrctlst/extra_rtbrace.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace2.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace2.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstruction/nodo.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstruction/nodo.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstruction/nofd1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstruction/nofd1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstruction/nofd2.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstruction/nofd2.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstruction/nofd3.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstruction/nofd3.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstruction/noset.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstruction/noset.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakInstruction/undefinedVar.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakInstruction/undefinedVar.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakMain/noinstruction.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakMain/noinstruction.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakMain/nolfbrace1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakMain/nolfbrace1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakMain/nolfbrace2.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakMain/nolfbrace2.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakMain/nolfbrace3.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakMain/nolfbrace3.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakPolish/InfixNotation.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakPolish/InfixNotation.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakPolish/PrefixNotation.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakPolish/PrefixNotation.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakPolish/no suff varnum.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakPolish/no suff varnum.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakPolish/noop1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakPolish/noop1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakPolish/noop2.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakPolish/noop2.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakPolish/nosemicolon.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakPolish/nosemicolon.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakPolish/novarnum.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakPolish/novarnum.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakPolish/undefinedVar.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakPolish/undefinedVar.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakSet/no:=1.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakSet/no:=1.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakSet/no:=2.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakSet/no:=2.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakSet/no:=3.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakSet/no:=3.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/UnitTest/breakSet/novar.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/breakSet/novar.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/breakDo.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/breakDo.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/breakInstrctlst.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/breakInstrctlst.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/breakInstruction.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/breakInstruction.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/breakMain.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/breakMain.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/breakPollish.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/breakPollish.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/break-samples/breakSet.ttl" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/breakSet.ttl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/makefile" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/minunit.h" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/UnitTest/minunit.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/test/testinterp.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/test/testinterp.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/test/testparser.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/test/testparser.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/test/testpoint.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/test/testpoint.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/test/testrealloc.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/test/testrealloc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/test/teststack.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/test/teststack.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/testing.txt" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/testing.txt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../Turtle/unittest.c" beforeDir="false" afterPath="$PROJECT_DIR$/Turtle/break-samples/unittest.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/4.1.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/bigglider_106.lif" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/bigun_106.lif" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/blinkerpuffer2_106.lif" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/glider_106.lif" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/gosperglidergun_106.lif" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/neillncurses.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/neillncurses.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap 4/4.1/newgun2_106.lif" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap1/hellosdl.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap1/hellosdl.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap11/Parsing/0's &amp;1's  Exp.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap11/Parsing/0's &amp;1's  Exp.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap11/Parsing/0's &amp;1's Formal Grammars" beforeDir="false" afterPath="$PROJECT_DIR$/../chap11/Parsing/0's &amp;1's Formal Grammars" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap11/Parsing/Implementing Reverse Polish.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap11/Parsing/Implementing Reverse Polish.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap11/Parsing/Mathematical Expression.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap11/Parsing/Mathematical Expression.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap11/Parsing/Parser -&gt; Interpreter.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap11/Parsing/Parser -&gt; Interpreter.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap11/Parsing/notes.txt" beforeDir="false" afterPath="$PROJECT_DIR$/../chap11/Parsing/notes.txt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap4/C13-advanced scanf()_char filter.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap4/C13-advanced scanf()_char filter.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap4/C13-sscanf(), fgets().c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap4/C13-sscanf(), fgets().c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/*Simple Search/Binary Search.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/*Simple Search/Binary Search.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/*Simple Search/Notes: time &amp; which cmd" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/*Simple Search/Notes: time &amp; which cmd" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/*Simple Search/Ordered Sequential Search.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/*Simple Search/Ordered Sequential Search.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/*Simple Search/Sequential Search .c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/*Simple Search/Sequential Search .c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/Makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/Notes- Overflow &amp; Recursion.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/Notes- Overflow &amp; Recursion.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/Permuting .c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/Permuting .c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/Power.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/Power.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/fibonacci.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/fibonacci.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/maze.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/maze.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/maze.dSYM/Contents/Resources/DWARF/maze" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/maze.dSYM/Contents/Resources/DWARF/maze" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/maze.txt" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/maze.txt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/openfile.dSYM/Contents/Resources/DWARF/openfile" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/openfile.dSYM/Contents/Resources/DWARF/openfile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/rec2.dSYM/Contents/Resources/DWARF/rec2" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/rec2.dSYM/Contents/Resources/DWARF/rec2" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/rec3.dSYM/Contents/Resources/DWARF/rec3" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/rec3.dSYM/Contents/Resources/DWARF/rec3" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/str_reverse.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/str_reverse.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/unlock_phone.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/unlock_phone.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap5/Recursion/unlock_phone.dSYM/Contents/Resources/DWARF/unlock_phone" beforeDir="false" afterPath="$PROJECT_DIR$/../chap5/Recursion/unlock_phone.dSYM/Contents/Resources/DWARF/unlock_phone" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap6/ADTs: Collection/Using_coll.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap6/ADTs: Collection/Using_coll.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap6/ADTs: Collection/coll.h" beforeDir="false" afterPath="$PROJECT_DIR$/../chap6/ADTs: Collection/coll.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap6/ADTs: Collection/realloc.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap6/ADTs: Collection/realloc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap6/ADTs: Collection/specific_Dynamic Array.h" beforeDir="false" afterPath="$PROJECT_DIR$/../chap6/ADTs: Collection/specific_Dynamic Array.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap6/ADTs: Collection/specific_Fixed Array.h" beforeDir="false" afterPath="$PROJECT_DIR$/../chap6/ADTs: Collection/specific_Fixed Array.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap6/ADTs: Collection/specific_Linked List.h" beforeDir="false" afterPath="$PROJECT_DIR$/../chap6/ADTs: Collection/specific_Linked List.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap7/ADT:Stack/linked.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap7/ADT:Stack/linked.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap7/ADT:Stack/realloc.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap7/ADT:Stack/realloc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap7/ADT:Stack/specific_linked=dynamic.h" beforeDir="false" afterPath="$PROJECT_DIR$/../chap7/ADT:Stack/specific_linked=dynamic.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap7/ADT:Stack/stack.h" beforeDir="false" afterPath="$PROJECT_DIR$/../chap7/ADT:Stack/stack.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/Cuckoo/cuckoo.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/Cuckoo/specific.h" beforeDir="false" afterPath="$PROJECT_DIR$/Hashing/Realloc/specific.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/Hashing/Makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/Realloc/realloc.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/Realloc/specific.h" beforeDir="false" afterPath="$PROJECT_DIR$/Hashing/Cuckoo/specific.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/assoc.h" beforeDir="false" afterPath="$PROJECT_DIR$/Hashing/assoc.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/assoc.mk" beforeDir="false" afterPath="$PROJECT_DIR$/Hashing/assoc.mk" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/notes/Notes-realloc.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap9/Hashing/notes/Notes-realloc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/notes/Notes-specific.h" beforeDir="false" afterPath="$PROJECT_DIR$/../chap9/Hashing/notes/Notes-specific.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/notes/Notes.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap9/Hashing/notes/Notes.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/notes/testassoc.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test.c" beforeDir="false" afterPath="$PROJECT_DIR$/Hashing/test.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test.dSYM/Contents/Info.plist" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test.dSYM/Contents/Resources/DWARF/test" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test2.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test3" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test3.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test3.dSYM/Contents/Info.plist" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/test3.dSYM/Contents/Resources/DWARF/test3" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testassoc.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap9/Hashing/notes/testassoc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testassoc2.c" beforeDir="false" afterPath="$PROJECT_DIR$/Hashing/testassoc2.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testcuckoo" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testcuckoo_s" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testcuckoo_s.dSYM/Contents/Info.plist" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testcuckoo_s.dSYM/Contents/Resources/DWARF/testcuckoo_s" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testcuckoo_v" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testcuckoo_v.dSYM/Contents/Info.plist" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testcuckoo_v.dSYM/Contents/Resources/DWARF/testcuckoo_v" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testrealloc" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testrealloc2" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testrealloc_s" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testrealloc_s.dSYM/Contents/Info.plist" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testrealloc_s.dSYM/Contents/Resources/DWARF/testrealloc_s" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testrealloc_v" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testrealloc_v.dSYM/Contents/Info.plist" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/3nd Hashing/testrealloc_v.dSYM/Contents/Resources/DWARF/testrealloc_v" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../chap9/Hashing/Separate_Chaining.c" beforeDir="false" afterPath="$PROJECT_DIR$/../chap9/Hashing/Separate_Chaining.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/Makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/data/demo_neillsimplescreen.c" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/data/demo_neillsimplescreen.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/data/neillsimplescreen.c" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/data/neillsimplescreen.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/data/neillsimplescreen.h" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/data/neillsimplescreen.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/data/title.png" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/data/title.png" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/data/title_extension.png" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/data/title_extension.png" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/feedback/ExampleFromNeill.c" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/feedback/ExampleFromNeill.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/feedback/general" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/feedback/general" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/feedback/personal" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/feedback/personal" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/forest" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/forest" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../forestFire/forest.c" beforeDir="false" afterPath="$PROJECT_DIR$/forestFire/forest.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../stacks" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../stacks.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../test/func_b1" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../transfer.c" beforeDir="false" afterPath="$PROJECT_DIR$/../transfer.c" afterDir="false" />
+    </list>
+    <option name="SHOW_DIALOG" value="false" />
+    <option name="HIGHLIGHT_CONFLICTS" value="true" />
+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
+    <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="ClangdSettings">
+    <option name="formatViaClangd" value="false" />
+  </component>
+  <component name="Git.Settings">
+    <option name="PUSH_TAGS">
+      <GitPushTagMode>
+        <option name="argument" value="--tags" />
+        <option name="title" value="All" />
+      </GitPushTagMode>
+    </option>
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
+  </component>
+  <component name="ProjectId" id="1pUjXP2gjCYJ2InWttKUyRNpoUE" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
+  <component name="ProjectViewState">
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showExcludedFiles" value="false" />
+    <option name="showLibraryContents" value="true" />
+    <option name="showMembers" value="true" />
+  </component>
+  <component name="PropertiesComponent">
+    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
+    <property name="WebServerToolWindowFactoryState" value="false" />
+    <property name="cf.first.check.clang-format" value="false" />
+    <property name="last_opened_file_path" value="$PROJECT_DIR$/Turtle" />
+  </component>
+  <component name="RecentsManager">
+    <key name="MoveFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/Turtle/break-samples/UnitTest" />
+      <recent name="$PROJECT_DIR$/Turtle/break-samples" />
+    </key>
+    <key name="CopyFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/Turtle" />
+      <recent name="$PROJECT_DIR$/Hashing" />
+    </key>
+  </component>
+  <component name="RunManager">
+    <configuration default="true" type="GradleAppRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" PASS_PARENT_ENVS_2="true">
+      <method v="2">
+        <option name="com.jetbrains.cidr.cpp.gradle.execution.GradleNativeBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+  </component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
+  <component name="TaskManager">
+    <task active="true" id="Default" summary="Default task">
+      <changelist id="a25fd582-e8dd-4087-a8b6-c9b0d7e21e39" name="Default Changelist" comment="" />
+      <created>1615244601691</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1615244601691</updated>
+      <workItem from="1615244602832" duration="1283000" />
+    </task>
+    <servers />
+  </component>
+  <component name="TypeScriptGeneratedFilesManager">
+    <option name="version" value="3" />
+  </component>
+  <component name="Vcs.Log.Tabs.Properties">
+    <option name="TAB_STATES">
+      <map>
+        <entry key="MAIN">
+          <value>
+            <State>
+              <option name="FILTERS">
+                <map>
+                  <entry key="branch">
+                    <value>
+                      <list>
+                        <option value="master" />
+                      </list>
+                    </value>
+                  </entry>
+                </map>
+              </option>
+            </State>
+          </value>
+        </entry>
+      </map>
+    </option>
+  </component>
+  <component name="WindowStateProjectService">
+    <state x="446" y="270" key="#com.intellij.fileTypes.FileTypeChooser" timestamp="1615245340561">
+      <screen x="0" y="23" width="1440" height="877" />
+    </state>
+    <state x="446" y="270" key="#com.intellij.fileTypes.FileTypeChooser/0.23.1440.877@0.23.1440.877" timestamp="1615245340561" />
+    <state x="320" y="201" key="Vcs.Push.Dialog.v2" timestamp="1615245581847">
+      <screen x="0" y="23" width="1440" height="877" />
+    </state>
+    <state x="320" y="201" key="Vcs.Push.Dialog.v2/0.23.1440.877@0.23.1440.877" timestamp="1615245581847" />
+    <state x="493" y="357" key="git4idea.remote.GitConfigureRemotesDialog" timestamp="1615245553505">
+      <screen x="0" y="23" width="1440" height="877" />
+    </state>
+    <state x="493" y="357" key="git4idea.remote.GitConfigureRemotesDialog/0.23.1440.877@0.23.1440.877" timestamp="1615245553505" />
+  </component>
+</project>
\ No newline at end of file
Index: ../2nd/2nd.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2020/11/21.\n//\n\n
===================================================================
--- ../2nd/2nd.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../2nd/2nd.c	(date 1615245742488)
@@ -1,4 +1,139 @@
-//
-// Created by Karine Liang on 2020/11/21.
-//
+//Happy Bookcases -- searching boards
+
+
+//In the file, an empty space is defined by a full-stop character.
+#define SPACE '.'
+
+
+//Variables:
+//each structure in the list will need to contain (amongst other things) a bookcase and a record of its parent bookcase
+//For an array, this could simply be which element of the array was the parent, or for a linked list, this will be a pointer.
+
+struct bookcase{
+    char book[H][W];
+    struct bookcase *child;
+    struct bookcase *parent;
+};
+typedef struct bookcase bookcase;
+
+
+//Functions:
+
+
+//  a bookcase is only happy if :
+def check_happiness():
+    return
+//• Each shelf only has books of one colour (or is empty).
+    如果第一格不是
+def samecolor_on_sameline():
+
+行间找有无重复的颜色,找有无重复的empty
+    for j in range(int HEIGHT):
+
+列间判断是否都是空格,或都是同一字母
+    for i in range(int shelf_maximum_size - 1):
+    if (isletter(grid[i]){
+
+    }
+    if (grid[i]==grid[++i]){
+        return true;
+    }
+    return false;
+
+    if (!isempty){
+        if(isbook)
+    }
+
+def isempty():
+
+//• All books of the same colour are on the same shelf.
+//• The only books that exists are black(K), red(R), green(G), yellow(Y), blue(B), magenta(M), cyan(C) or white(W).
+（颜色到底属于检验输入文件的有效性，还是检验是否happy呢？）-->更偏向于检验happy的标准。、
+
+
+//Must use the algorithm - similar to a Queue and a breadth-first search.
+//how books may be rearranged :
+//1. You can only move one book at a time.
+//2. The only book that can move is the rightmost one from each shelf.
+//3. The book must move to become the rightmost book on its new shelf.
+//4. You can’t put more books on a shelf than its maximum size.
+
+// searching over all moves to make the bookcase happy goes like this :
+//1. You will use a list of bookcases (here list could either be an array, or a linked list).
+//2. The initial bookcase is put into the front of this list.
+//3. Take a bookcase from the front of the list.
+//4. For this (parent) bookcase, find the resulting (child) bookcases which can be created from all the valid possible single book moves.
+// Put each of these bookcases into the end of the list. There may be as many as height ×(height −1) of these.
+// If you have found a happy bookcase, stop. Else, go to 3.
+
+
+
+
+---------FILE READING && VALIDITIY----------
+//The program reads the name of the bookcase definition file from argv[1].
+int main(int argc, char* argv[])
+{
+    FILE *fp;
+    if((fp = fopen(argv[1], "r")) == NULL) {
+        printf("Cannot read file\n");
+    }
+    exit(EXIT_FAILURE);
+}
 
+//Should check for invalid bookcase definition files, and report in a graceful way if there is a problem, aborting with exit(EXIT_FAILURE) if so.
+//The first line has two or three numbers on it; the height of the bookcase (number of shelves),
+//the width (maximum books per shelf) and an optional hint as to the minimum number of bookcases involved when ‘solving’ this bookcase.
+//You may assume that the maximum height and width of a bookcase is 9.
+检查输入文件定义的有效性:
+def check_validity():
+return check_firstline()&&check_input_bookcase:
+
+    def check_firstline():
+    return check_length()&&check_digit&range();
+    1)第一行数字 (数字个数是否为2/3个,前两个字符是否in range(int 1<=H<=9,1<=W<=9))
+    @怎样只扫描文件第一行的数字?  //fscanf(stdin, "%d", &n);
+    判断该行字符个数是否3个以内:
+    def check_length:
+    int cnt=0;
+    while(grid!='\0'){
+        cnt++;
+    }
+    if (cnt>3){
+        return false
+    }
+    return true;
+    判断该行字符是否为数字，如果是数字是否在范围内:
+    def check_digit&range:
+        for i in range(2):
+            if (isdigit(gird)&&(1<=grid<=9){
+                return true;
+            }
+            return false;
+
+
+    2)对输入的bookcase是否有除 书 & 句号 以外的字符
+    def check_input_bookcase:
+    for i in range(H), for j in range(W):
+        if (!isbook(grid)&&!(grid==SPACE)){
+            return false;
+        }
+        return true;
+
+    def isbook(char b):
+        if (b=='K'||b=='R'||b=='G'||b=='Y'||b=='B'||b=='M'||b=='C'||b=='W'){
+            return true;
+        }
+        return false;
+    3)输入的bookcase第一行与例子是否言行一致，即每行/列的 实际字母数+空格数 需要检验吗？
+    已知可以假设书都是靠左放的。
+
+
+---------PRINT OUTPUTS & DISPLAY----------
+//If the bookcase happy, it prints out the number of bookcases, that would be printed in the solution and nothing else, or else exactly the phrase ‘No Solution?”
+//If the ‘verbose’ flag is used (argv[2]), your program will additionally print out the solution (reverse order if fine)
+//May display the bookcases in colour if you wish - if so use neillsimplescreen to do so.
+
+
+// Extension:
+// a brief description in a extension.txt file.
+// This could involve a faster search technique, better graphical display, user input or something else of your choosing.
\ No newline at end of file
Index: ../chap1/hellosdl.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2021/1/25.\n//\n\n
===================================================================
--- ../chap1/hellosdl.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap1/hellosdl.c	(date 1615245742554)
@@ -1,4 +1,24 @@
-//
-// Created by Karine Liang on 2021/1/25.
-//
+#include <SDL2/SDL.h>
 
+int main (int argc, char** argv)
+{
+    SDL_Window* window = NULL;
+    window = SDL_CreateWindow("Hello SDL2", SDL_WINDOWPOS_UNDEFINED,
+                              SDL_WINDOWPOS_UNDEFINED,640,480,SDL_WINDOW_SHOWN);
+    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
+    SDL_SetRenderDrawColor(renderer, 90, 90, 255, 255 );
+    SDL_RenderClear(renderer);
+    SDL_RenderPresent(renderer);
+    int quit = 0;
+    SDL_Event e;
+    while (!quit) {
+        while (SDL_PollEvent(&e)) {
+            if (e.type == SDL_QUIT) {
+                quit = 1;
+            }
+        }
+    }
+    SDL_DestroyWindow(window);
+    SDL_Quit();
+    return EXIT_SUCCESS;
+}
\ No newline at end of file
Index: ../chap5/Recursion/maze.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>10 10\n##########\n  #      #\n# # # ## #\n# # #### #\n# #    # #\n# # #### #\n# #    # #\n# #### # #\n#      #\n##########
===================================================================
--- ../chap5/Recursion/maze.txt	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/maze.txt	(date 1615245742577)
@@ -7,5 +7,5 @@
 # # #### #
 # #    # #
 # #### # #
-#      #
+#      # *
 ##########
\ No newline at end of file
Index: ../chap4/C13-sscanf(), fgets().c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* The Sscanf() Function\n//int sscanf(char *s, char *format, other args);\n//sscanf()和scanf相似，不同点在sscanf()是从字符串读取数据输入，而scanf是从键盘读取数据输入。*/\n#include <stdio.h>\n#include <stdlib.h>\n\n#define STRLN 100\n\nint main(void)\n{\n    char str[STRLN];\n    int i;\n    fgets(str, STRLN, stdin);/*fgets(* strname, int size, FILE* ); 需要知道和定义数组大小！这样就不会覆写数组的结尾。这里stdin是键盘的预定义文件指针。\n                             //对比gets()：gets()是不安全的，同样从键盘读入，但允许覆写数组的结尾。*/\n    while(sscanf(str, \"%d\", &i) != 1){  /*从由fgets得到的一行输入（fgets遇到新行 结束输入）文本字符串中找数字，存到i中。\n                                        //这里从输入值开头开始找，数字前面有任何字母、空格字符等垃圾值，sscanf不会扔掉，因此不能通过sscanf!=1,会按下面格式报错。\n                                        //直到输入值是数字开头为止，可丢弃数字后面的垃圾值。*/\n        printf(\"Cannot scan string !\\n\");\n        fgets(str, STRLN, stdin);/*如果失败了，调用fgets继续调取下一行字符串输入。直到上面的sscanf成功从新的str中扫到一个整型数字。*/\n    }\n    printf(\"The number was %d.\\n\", i);\n    return 0;\n}\n
===================================================================
--- ../chap4/C13-sscanf(), fgets().c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap4/C13-sscanf(), fgets().c	(date 1615245742586)
@@ -13,8 +13,8 @@
     fgets(str, STRLN, stdin);/*fgets(* strname, int size, FILE* ); 需要知道和定义数组大小！这样就不会覆写数组的结尾。这里stdin是键盘的预定义文件指针。
                              //对比gets()：gets()是不安全的，同样从键盘读入，但允许覆写数组的结尾。*/
     while(sscanf(str, "%d", &i) != 1){  /*从由fgets得到的一行输入（fgets遇到新行 结束输入）文本字符串中找数字，存到i中。
-                                        //这里从输入值开头开始找，数字前面有任何字母、空格字符等垃圾值，sscanf不会扔掉，因此不能通过sscanf!=1,会按下面格式报错。
-                                        //直到输入值是数字开头为止，可丢弃数字后面的垃圾值。*/
+                                        * 这里从输入值开头开始找。一旦数字前面有任何字母、空格字符等垃圾值，sscanf也不会扔掉，因此不能通过sscanf!=1,而是sscanf=2、3...
+                                        * 直到输入值是数字开头为止，可丢弃数字后面的垃圾值。*/
         printf("Cannot scan string !\n");
         fgets(str, STRLN, stdin);/*如果失败了，调用fgets继续调取下一行字符串输入。直到上面的sscanf成功从新的str中扫到一个整型数字。*/
     }
Index: ../chap11/Parsing/Mathematical Expression.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2020/12/22.\n//\n\n
===================================================================
--- ../chap11/Parsing/Mathematical Expression.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap11/Parsing/Mathematical Expression.c	(date 1615245742590)
@@ -1,4 +1,85 @@
-//
-// Created by Karine Liang on 2020/12/22.
-//
+/* Mathematical Expressions
+To parse a string such as ”A+B*C”, ”A*(B+C)” or
+”-(B*F)” we use : 检查数学表达式的语法。这里-是负号。 */
+
+/* Formal grammar有时不会告诉我们所有需要的信息，比如a+b是否正确说明不清晰，space如何处理也不清晰。*/
+
+
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#define MAXEXPR 400
+
+struct prog{
+    char str[MAXEXPR];/* 注意这里的字符串数组大小只是暂时用Fixed sized的，作业时要用灵活大小的，这样程序适应性更强 */
+    int count;
+};
+typedef struct prog Prog;
 
+void Op(Prog *p);
+int isop(char c);
+void Expr(Prog *p);
+
+int main(void)
+{
+    Prog p;
+    p.count = 0;
+    if(scanf("%[A-Z,+,-,*,/,(,)]s", p.str) != 1){ /*这里用了scan set："%[.., .., ..]s"只扫描set里的字符，一旦遇其他字符就终止。*/
+        printf("Couldn’t read your expression ?\n");
+        exit(2);
+    }
+    Expr(&p);
+    printf("Parsed OK !\n");
+    return 0;
+}
+/*-------------------------------------------------------*/
+<EXPR> ::= <EXPR><OP><EXPR> | "(" <EXPR> ")" | "-"<EXPR> | Letter
+<OP> ::= "+" | "-" | "*" | "/"
+
+int isop(char c)
+{
+    if(c=='+'|| c=='-' || c=='*' || c=='/')
+        return 1;
+    else
+        return 0;
+}
+void Op(Prog *p)
+{
+    if(!isop(p->str[p->count])){
+        printf("I was expecting a letter ?\n");/*由于isop才能进入OP,那这行代码是不是永远不会到达呢？还有为什么是期待letter？*/
+        exit(2);
+    }
+}
+void Expr(Prog *p) /* 多个选项，需要靠 "第一个规则判断" 进入哪个选项，"第二个规则自动顺联执行" 即可。 */
+{
+    if(p->str[p->count] == '('){/* 一旦碰到左括号就call这个函数，并要确保检查是否有右关闭括号。*/
+        p->count = p->count + 1;
+        Expr(p);
+        p->count = p->count + 1;
+        if(p->str[p->count] != ')'){ /*执行完（<Expr>）后，指针指着")"。*/
+            printf("I was expecting a ) ?\n");/*第一个具体字符用于匹配，匹配确认是这个结构后，最后一个必须字符若不存在则报错*/
+            exit(2);
+        }
+    }
+    else if(p->str[p->count] == '-'){
+        p->count = p->count + 1;  /* 坐标角度看，是马上要执行下一个规则时（这里是Expr前）将坐标向右移一位 */
+        Expr(p);  /* 执行完Expr，此时坐标仍指着Expr */
+    }
+/* Note Look-Ahead */
+/* 需要区别<Letter>和<EXP><OP><EXP>，而第一个字符可能会一样。所以这里跳过首字符的判断，所有读取字符都是相连的，所以可以直接count+1判断*/
+    else if(isop(p->str[p->count+1])){/* 此时用count+1，即count本身不变，但以其为基准检查偏移量坐标的内容。判断用isxxx函数，执行用XX函数。*/
+        if(isupper(p->str[p->count])){/*若为真 可能是<Letter><OP><EXP>或-<Letter><OP><EXP> ；漏洞：若为负，可能是(<EXP>)<OP><EXP>。*/
+            p->count = p->count + 1;/* 已判断完第一个字符，要执行第二个字符，所以指针移向下一位*/
+            Op(p);
+            p->count = p->count + 1;
+            Expr(p);
+        }
+    }
+    else{
+        if(!isupper(p->str[p->count]) ||
+           isupper(p->str[p->count+1])){/*前面所有情况都不符合的话，判断是letter,排错：当前是非法字符，letter+letter，以及非法字符+letter*/
+            printf("Expected a single letter ?\n");/*这里letter无需单独成部分，因为在判断时直接就确定是letter了，那么只需要报错即可。*/
+            exit(2);
+        }
+    }
+}
Index: ../chap11/Parsing/Parser -> Interpreter.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2020/12/22.\n//\n\n
===================================================================
--- ../chap11/Parsing/Parser -> Interpreter.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap11/Parsing/Parser -> Interpreter.c	(date 1615245742594)
@@ -1,4 +1,17 @@
-//
-// Created by Karine Liang on 2020/12/22.
-//
+/*【Parser ->拓展到 Interpreter】
+An interpreter both checks the syntax and performs the required operations
+        Parser只检查语法，而Interpreter检查语法+执行所要求的操作。*/
+/* 比如：简单修改Parser代码，可以获得简单的Interpreter：*/
+void Statement(Program *p)
+{
+    if(strsame(p->wds[p->cw], "ONE")){
+        printf("1\n"); /* 这里根据程序要求的"1"，执行"打印1"操作，就是Interpreter的操作 */
+        return;
+    }
+    if(strsame(p->wds[p->cw], "NOUGHT")){
+        printf("0\n");
+        return;
+    }
+    ERROR("Expecting a ONE or NOUGHT ?");
+}
 
Index: ../chap11/Parsing/0's &1's Formal Grammars
===================================================================
--- ../chap11/Parsing/0's &1's Formal Grammars	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap11/Parsing/0's &1's Formal Grammars	(date 1615245742597)
@@ -1,0 +1,3 @@
+<PROG> ::= "BEGIN" <CODE>
+<CODE> ::= "END" | <STATEMENT> <CODE>           /* 这里<CODE>是递归的 */
+<STATEMENT> ::= "ONE" | "NOUGHT"
\ No newline at end of file
Index: ../chap11/Parsing/0's &1's  Exp.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2020/12/21.\n//\n\n
===================================================================
--- ../chap11/Parsing/0's &1's  Exp.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap11/Parsing/0's &1's  Exp.c	(date 1615245742608)
@@ -1,4 +1,79 @@
-//
-// Created by Karine Liang on 2020/12/21.
-//
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#define MAXNUMTOKENS 100   /* 100个字符串 */
+#define MAXTOKENSIZE 7     /* 每个字符串长为7 */
+#define PROGNAME "01.no"   /* 所打开文件名为固定名 */
+#define strsame(A,B) (strcmp(A, B)==0)  /* 用define将strcmp==0改名为strsame，免去注释 */
+#define ERROR(PHRASE) {fprintf(stderr,\
+"Fatal Error %s occured in %s, line %d\n",\
+PHRASE, __FILE__, __LINE__); exit(2); } /* 报错：字符串名、行&列位置*/
+
+struct prog{
+    char wds[MAXNUMTOKENS][MAXTOKENSIZE];
+    int cw; /* Current Word -- 相当于查询时用的counter，而不是数组里所存token数的cnt */
+};
+typedef struct prog Program;
+
+void Prog(Program *p);
+void Code(Program *p);
+void Statement(Program *p);
 
+
+int main(void)
+{
+    int i;
+    FILE *fp;
+    Program prog;
+
+    /* 初始化存放所读文件字符串的数组与计数器。 */
+    prog.cw = 0;
+    for(i=0; i<MAXNUMTOKENS; i++)
+        prog.wds[i][0] = '\0';/* 将每个字符串第一个字母初始化成NULL（类似Calloc后），使其存储的都是有效字符串*/
+
+    /* 确认文件存在，可以打开它*/
+    if(!(fp = fopen(PROGNAME, "r"))){
+        fprintf(stderr, "Cannot open %s\n",PROGNAME);
+        exit(2);
+    }
+    /* 用fscanf从第0个位置起，从文件扫描字符串存储到struct的数组中。fscanf识别以空格为间隔符。 */
+    i=0;
+    while(fscanf(fp, "%s", prog.wds[i++])==1 && i<MAXNUMTOKENS);/* while();表示一直执行括号内，直到括号内条件不再为真。*/
+    assert(i<MAXNUMTOKENS);/* 确保没有overwrite数组。上面终止条件是扫不到字符串/字符串长度超过，前者属于期望的正常情况，后者应终止程序重设长度（否则无人知道地发生信息丢失）   */
+    Prog(&prog);/* 检查程序 */
+    printf("Parsed OK\n");/* 反馈：语法正确 */
+    return 0;
+}
+/*-------------------------------------------------------*/
+<PROG> ::= "BEGIN" <CODE>
+<CODE> ::= "END" | <STATEMENT> <CODE>
+<STATEMENT> ::= "ONE" | "NOUGHT"
+
+/* 层层递归的语法检查。 */
+void Prog(Program *p)
+{
+    if(!strsame(p->wds[p->cw], "BEGIN"))/* 检查第一个词是否为BEGIN。wds[]是底层数组 cw是数组内已有字符串个数，也是"第几个数组" */
+        ERROR("No BEGIN statement ?");/* 必须以xx开头的结构，是就计数+下一结构，否就报错。*/
+    p->cw = p->cw + 1;/* 如果是BEGIN，counter + 1，因为BEGIN也占一个字符串*/
+    Code(p);/*根据语法构成 下一步是<CODE>*/
+}
+void Code(Program *p)
+{
+    if(strsame(p->wds[p->cw], "END"))
+        return;/* 因为cnt+1后得到的数字是存下一个字符串的，而END后面没字符串了，所以无需+1。最终实际个数=cnt+1。没问题就安静地return。*/
+    Statement(p);/* xx | xx的结构，先比对是不是简单一点的那项，如果不是，那就执行另一项（如果两项都不是的报错，在默认的另一项的下面报错） */
+    p->cw = p->cw + 1;/* 每执行一次小结构并成功返回（即return回这里了）就计数一次，然后执行下一部分；执行到结尾的}时不用变计数器，因为计数器作用只是用于下一格字符的比对。*/
+    Code(p);
+}
+void Statement(Program *p)
+{
+    if(strsame(p->wds[p->cw], "ONE")){ /* 因为只有具体的字符串比对如"END"、"{"，容易报错，非黑即白；但无具体字符的，如判断是否为某结构体的，无法直接比对，其比对下沉到其下面的具体字符串的比对。*/
+        return;
+    }
+    if(strsame(p->wds[p->cw], "NOUGHT")){
+        return;
+    }
+    ERROR("Expecting a ONE or NOUGHT ?")/*非0、非1后的第3种情况。*/
+}
\ No newline at end of file
Index: ../chap5/Recursion/unlock_phone.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"neillsimplescreen.h\"\n\ntypedef enum bool{false,true} bool;\n\n#define SIZE 3\n#define BLANK '\\0'\n\nvoid possPath(char a[SIZE][SIZE],int x, int y, int len);/*递归函数，用于探索每格附近有无有效格*/\nbool valid(char[SIZE][SIZE],int x, int y);/*用于检查格子是否为可通行的有效格*/\nvoid printphone(char a[SIZE][SIZE]);\n\nint main(void)\n{\n    char sc[SIZE][SIZE] = {{BLANK}};\n    possPath(sc,0,0,SIZE*SIZE);/*传递数组名指针，起点横纵坐标--(0,0)是左上角，解锁路径长度*/\n    return 0;\n}\n\n/*检查有效性  实则为(1)检查是否超出边界、是否safe的函数！PS:数组坐标的边界是<0 和 >=SIZE(不能等于SIZE)\n//(2)检查是否为走过的格子，走过则归为无效。因此走过的路要将空格修改为符号表示（记得每次递归结束要trackback，为下次循环进入新路径准备）*/\nbool valid(char a[SIZE][SIZE],int x, int y)\n{\n    if((x<0)||(y<0)||(x>=SIZE)||(y>=SIZE)){\n        return false;\n    }\n    if(a[y][x]!=BLANK){\n        return false;\n    }\n    return true;\n}\n\nvoid printphone(char a[SIZE][SIZE])\n{\n    int i,j;\n    char bar[SIZE*2+2];/* 要打印出格子的样式，所以这个是最上面和最下面的外格线，\n                       // 由于每一格内容+一格\"｜\"，因此是size*2,+1是因为两头全包｜的需要，\n                       // 再+1是因为【字符串数组】，最后【需要加上结束符'\\0'】占一格！！*/\n    neillfgcol(white);\n    memset(bar,'-',SIZE*2+1);\n    bar[SIZE*2+1]='\\0';/*手动赋值整个字符串数组的，结尾手动加上结束符。*/\n    for(j=0;j<SIZE;j++){\n        neillfgcol(white);/*打印一行白色的\"-\"。*/\n        printf(\"%s\\n\",bar);\n        for(i=0;i<SIZE;i++){\n            neillfgcol(white);\n            printf(\"|\");\n            neillfgcol(red);/*这里表示打印一个白色的\"｜\"，就紧跟着打印一个红色的数组字符*/\n            printf(\"%c\",a[j][i]);\n        }\n        neillfgcol(white);\n        printf(\"|\\n\");/* 因为｜比字符c多一个，无法用循环做，在内部循环后，再单独打印一个白色的｜。*/\n    }\n    printf(\"%s\\n\",bar);\n    neillreset();\n}\n\nvoid possPath(char a[SIZE][SIZE],int x, int y, int len)\n{\n    static int c = 0;/*计数变量c\n    //当递归至len==1时，说明一条路已递归结束，就需要做print这条路线,还有输出这是第几条路。*/\n    if (len==1){\n        printphone(a);\n        printf(\"%d\\n\",++c);\n        return;\n    }\n    /*向左探索*/\n    if (valid(a,x-1,y)){\n        a[y][x] = '<';\n        possPath(a,x-1,y,len-1);/*如果存在向左的路，递归式一路向左探索到底。注意递归时传递 x-1 同时要 len-1！*/\n        a[y][x] = BLANK;/* Backtrack很重要！探索式递归，需要做 mark/修改-递归-回溯改回来 */\n    }\n\n    /*向右*/\n    if (valid(a,x+1,y)){\n        a[y][x] = '>';\n        possPath(a, x + 1, y, len - 1);\n        a[y][x] = BLANK;\n    }\n\n    /*向上*/\n    if (valid(a,x,y+1)) {\n        a[y][x] = '>';\n        possPath(a, x, y+1, len - 1);\n        a[y][x] = BLANK;\n    }\n\n    /*向下*/\n    if (valid(a,x,y-1)) {\n        a[y][x] = '>';\n        possPath(a, x, y-1, len - 1);\n        a[y][x] = BLANK;\n    }\n}\n\n
===================================================================
--- ../chap5/Recursion/unlock_phone.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/unlock_phone.c	(date 1615245742617)
@@ -6,7 +6,7 @@
 typedef enum bool{false,true} bool;
 
 #define SIZE 3
-#define BLANK '\0'
+#define BLANK ' '
 
 void possPath(char a[SIZE][SIZE],int x, int y, int len);/*递归函数，用于探索每格附近有无有效格*/
 bool valid(char[SIZE][SIZE],int x, int y);/*用于检查格子是否为可通行的有效格*/
@@ -14,8 +14,13 @@
 
 int main(void)
 {
-    char sc[SIZE][SIZE] = {{BLANK}};
-    possPath(sc,0,0,SIZE*SIZE);/*传递数组名指针，起点横纵坐标--(0,0)是左上角，解锁路径长度*/
+    char sc[SIZE][SIZE];
+    int j;
+    for(j=0;j<SIZE;j++){
+        memset(sc[j],' ',SIZE);
+    }
+    /* char sc[SIZE][SIZE] = {{BLANK}}; 如果直接把 Blanck从'\0'改为空格，无法实现一次性全部赋值*/
+    possPath(sc,0,1,3);/*传递数组名指针、起点横纵坐标:(0,0)是左上角、路径长度*/
     return 0;
 }
 
@@ -41,7 +46,7 @@
     neillfgcol(white);
     memset(bar,'-',SIZE*2+1);
     bar[SIZE*2+1]='\0';/*手动赋值整个字符串数组的，结尾手动加上结束符。*/
-    for(j=0;j<SIZE;j++){
+    for(j=0;j<SIZE;j++){/*一格格打印格式和字符*/
         neillfgcol(white);/*打印一行白色的"-"。*/
         printf("%s\n",bar);
         for(i=0;i<SIZE;i++){
@@ -56,13 +61,16 @@
     printf("%s\n",bar);
     neillreset();
 }
-
+/*以poss这里的坐标为中心，检查周围坐标的可行性，如果存在可行的，修改poss这里的坐标、用符号标记一下。*/
 void possPath(char a[SIZE][SIZE],int x, int y, int len)
 {
     static int c = 0;/*计数变量c
     //当递归至len==1时，说明一条路已递归结束，就需要做print这条路线,还有输出这是第几条路。*/
+    /* 注意由于它四面都有空格时也只能改成一个方向，递归到底后返回上一层，又可以接着对别的方向递归，所以就存在多种可能。*/
     if (len==1){
+        a[y][x] ='*';
         printphone(a);
+        a[y][x] = BLANK;
         printf("%d\n",++c);
         return;
     }
@@ -76,21 +84,21 @@
     /*向右*/
     if (valid(a,x+1,y)){
         a[y][x] = '>';
-        possPath(a, x + 1, y, len - 1);
+        possPath(a, x+1, y, len-1);
         a[y][x] = BLANK;
     }
 
-    /*向上*/
-    if (valid(a,x,y+1)) {
-        a[y][x] = '>';
-        possPath(a, x, y+1, len - 1);
+    /*向下！因为(0,0)是左上角，那么(1,0)在其下面！*/
+    if (valid(a,x,y+1)){
+        a[y][x] = 'v';
+        possPath(a, x, y+1, len-1);
         a[y][x] = BLANK;
     }
 
-    /*向下*/
-    if (valid(a,x,y-1)) {
-        a[y][x] = '>';
-        possPath(a, x, y-1, len - 1);
+    /*向上*/
+    if (valid(a,x,y-1)){
+        a[y][x] = '^';
+        possPath(a, x, y-1, len-1);
         a[y][x] = BLANK;
     }
 }
Index: ../chap11/Parsing/notes.txt
===================================================================
--- ../chap11/Parsing/notes.txt	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap11/Parsing/notes.txt	(date 1615245742626)
@@ -1,0 +1,29 @@
+【命令行命令： echo $?】 查看返回值。    Eg：exit后用echo，返回值1，因为Exit_failure定义为1。
+
+【Reversed Polish：无括号、运算符后缀】
+用Stack方式实现！
+后到的数字push到最上面，一旦遇到运算符，pop最上面两个数字进行计算，将运算结果push进去；
+一旦peak有数，还未算完到只剩最后1个数，无法得到最终结果。
+
+【从运算符后缀->运算符前缀】
+需要用Queue的方式，或者string的方式实现！
+
+【可以用格式符来区别是读到了数字还是运算符（in Stack）】
+%d -- 读到数字
+其他 / %s --读到字符（串）
+
+【Parsing的定义】
+Parsing a program is the process of grammatically analysing how it is composed into parts.
+Parsing是用来分析语法是否正确的。
+Parser是写Compiler的基础。
+
+【Formal Grammar （in Parsing）】
+：：=定义
+<...>代表规则，应该又对规则的定义
+｜ 代表or（是完全分隔的或），"..."｜"..."｜"..."多种选项
+
+【有用的报错格式：】
+Expecting xxx or xxx ?/ I was expecting a xxx?
+No xxx at yyy ?
+Couldn't read your experssion?
+
Index: ../chap4/C13-advanced scanf()_char filter.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Advanced Scanf()\n#include <stdio.h>\nint main()\n{\n    char str[50];\n//(1) 使用scanf输入字符串时，可以明确一个\"scan set\"。\n// 只允许扫描set范围里的字符，一旦遇到其他字符(包括空格、回车、tab缩进字符等)就将终止扫描。\n\n    printf(\"Please type a string :\"); //abacus\n    scanf(\"%[abc]s\", str);\n    printf(\"I scanned : %s\\n\",str);//abac\n\n//要测试第二部分，先注释掉第一部分。\n// (2) 上三角符号用于明确唯独不在scanf set里面的字符。\n// 只有除了这些字符以外的字符可以被scanf使用。\n    printf(\"Please type a string :\");//I Am Crackers\n    scanf(\"%[^k]s\", str);\n    printf(\"I scanned : %s\",str); //I Am Crac\n    return 0;\n}\n
===================================================================
--- ../chap4/C13-advanced scanf()_char filter.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap4/C13-advanced scanf()_char filter.c	(date 1615245742630)
@@ -11,7 +11,7 @@
     printf("I scanned : %s\n",str);//abac
 
 //要测试第二部分，先注释掉第一部分。
-// (2) 上三角符号用于明确唯独不在scanf set里面的字符。
+// (2) 上三角符号用于明确唯独不在scan set里面的字符。
 // 只有除了这些字符以外的字符可以被scanf使用。
     printf("Please type a string :");//I Am Crackers
     scanf("%[^k]s", str);
Index: ../chap5/*Simple Search/Notes: time & which cmd
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>time 是一个内嵌在shell里的东西（并非程序）可以显示具体运行时间&占用内存\n命令：time + ./a.out\n\n二分法这里非递归用了约5.6秒，递归用了约7.9秒，因为递归调用了很多次函数是很expensive的
===================================================================
--- ../chap5/*Simple Search/Notes: time & which cmd	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/*Simple Search/Notes: time & which cmd	(date 1615245742634)
@@ -1,4 +1,13 @@
 time 是一个内嵌在shell里的东西（并非程序）可以显示具体运行时间&占用内存
 命令：time + ./a.out
+结果：X.XXs user X.XXs system XX% cpu X.XXX total
+eg: 非递归二分法用了约5.6秒，递归二分法用了约7.9秒。这是因为递归调用了很多次函数是很expensive的
+
+
+whcih显示某个文件/程序存储在哪个位置。
+命令：which + 指令名/程序文件名
+eg: which time
+    which ls
+结果：time: shell reserved word
+     /bin/ls
 
-二分法这里非递归用了约5.6秒，递归用了约7.9秒，因为递归调用了很多次函数是很expensive的
\ No newline at end of file
Index: ../transfer.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Karine Liang on 2021/2/11.\n//\n\n
===================================================================
--- ../transfer.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../transfer.c	(date 1615245742659)
@@ -1,4 +1,5 @@
-//
-// Created by Karine Liang on 2021/2/11.
-//
+#include "Turtle/General/general.h"
+void main{
+    //打开文件  
+};
 
Index: ../chap5/Recursion/Notes- Overflow & Recursion.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* 摘自https://blog.csdn.net/qq_34178562/article/details/78198755：\n * 出现栈内存溢出的常见原因有2个：\n    1. 函数递归调用层次过深，每调用一次，函数的参数、局部变量等信息就压一次栈，并且没有及时出栈。    //stack里随着递归调用堆积了很多个function，就满了；\n    2. 局部静态变量体积太大       //比如，在函数里定义很大的局部变量（例如大数组）；\n * 解决方案：\n    1.对于递归导致的overflow:\n    (1)把递归调用函数改用while或者for循环来实现。\n    (2)通过尾递归优化。尾递归是指在函数返回调用自身本身，并且return语句不能包含表达式（即return 函数名(参数)）。//将返回值作为函数的一个参数，这样只用最后保留最后一个堆栈即可。\n\n    2.对于局部静态变量太大导致的overflow:\n    (1)改用堆内存。——将局部变量改为静态变量（实质上也是全局变量）。\n    (2)增大栈的大小值。\n*/\n\n// 摘自https://blog.csdn.net/zcyzsy/article/details/77151709 :\n/* 栈Stack 存放程序的局部变量（不包括静态局部变量，static变量存在静态区）。除此以外，在函数被调用时，栈用来传递参数和返回值。\n * 由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。我们可以把堆栈看成一个寄存、交换临时数据的内存区。*/\n// --------------Factorial of Recursive way 普通递归方法的阶乘--------------\nint fact(int n) {\n    if (n < 0)\n        return 0;\n    else if (n == 0 || n == 1)\n        return 1;\n    else\n        return n * fact(n - 1);}\n//每次函数调用的返回值都依赖于用n乘以下一次函数调用的返回值，\n//因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。\n\n// --------------Factorial of Taill recursive way 尾递归方法的阶乘--------------\nint facttail(int n, int res)\n{\n    if (n < 0)\n        return 0;\n    else if(n == 0)\n        return 1;\n    else if(n == 1)\n        return res;\n    else\n        return facttail(n - 1, n *res);}\n//函数比代码1多个参数res，res（初始化为1）维护递归层次的深度，除此之外并没有太大区别。\n//在每次递归调用中，令res=n*res并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回res即可。\n//是尾递归的，因为对facttail的单次递归调用是函数返回前最后执行的一条语句。\n//换句话说，在递归调用【之后还可以有其他的语句执行】，只是它们【只能在递归调用没有执行时】才可以执行。\n\n\n/* 尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。\n * 比如sum(n) = f(n) = f(n-1) + value(n) 会保存n个函数调用堆栈；\n * 而使用尾递归f(n, sum) = f(n-1, sum+value(n)),这样则只保留后一个函数堆栈即可，之前的可优化删去。*/\n\n\n//另附：Tree和Recursion。递归求二叉树高度的求解思路，就是1+max{height(root->light),height(root->right)}。\nint height(BTree *p)\n{\n    int hi = 0,lh = 0,rh = 0;\n    if (p == NULL)\n        hi = 0;\n    else\n    {\n        if (p->lchild ==NULL)\n            lh = 0;\n        else\n            lh = height(p->lchild);//递归求解左子树的高度\n        if (p->rchild ==NULL)\n            rh = 0;\n        else\n            rh = height(p->rchild);//递归求解右子树的高度\n        hi = lh>rh ? (lh + 1) : (rh + 1);\n    }\n    return hi;\n}\n
===================================================================
--- ../chap5/Recursion/Notes- Overflow & Recursion.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/Notes- Overflow & Recursion.c	(date 1615245742716)
@@ -11,6 +11,39 @@
     (1)改用堆内存。——将局部变量改为静态变量（实质上也是全局变量）。
     (2)增大栈的大小值。
 */
+/* ------------Neill Q&A: 局部静态变量体积太大导致的memory leak--------------*/
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+int main(void)
+{
+    /* 方案1：改用堆内存*/
+    static char wds[400000000][40];/* 当这个超大数组被使用时，因为体积太大，会导致代码崩溃。可以将其改为static！
+                                    * static表示下次我们来到main时，这个数组不会被改变，但显然我们一般不会二次调用main，除非它调用自己。
+                                    * 改成static后，存储空间来自heap而不是stack。*/
+    /* 方案2：改用指向字符串的指针数组 */
+    char* wds[400000000]={NULL};/* 比起假设每个词有一定大小的固定大小的二维数组，改用指针数组*[]更加节省空间。NULL是指针，其值是0。想完全不用40000...要用到char**指向指针的指针！*/
+    char str[1000];
+    do{
+        fscanf(fp,"%s",str);/* 当从文件读取字符串。需要检查fscanf。*/
+        n=strlen(str);
+        wds[i]=malloc(n+1);/* malloc需要的size是字符串长度n+'\0'所占位1。每找到1个词，就创建符合该字符串大小的空间，并将该空间赋给指针wds[i]，来装字符串*/
+                           /* 前面创建的字符串指针数组（原本装的都为垃圾值），现在每格都指向一个空间，并在之后这些空间存到字符串了*/
+                           /* 需要检查malloc的返回值。*/
+        strcpy(wds[i],str);/* strcpy是内嵌函数，会自动在尾巴加一个'\0'，但自制函数可能需要手动加'\0'。*/
+    }while();
+
+    for(i=0;i<40000..;i++)
+    {
+        free(wds[i]);
+    }
+
+    return 0;
+}
+
+
+
 
 // 摘自https://blog.csdn.net/zcyzsy/article/details/77151709 :
 /* 栈Stack 存放程序的局部变量（不包括静态局部变量，static变量存在静态区）。除此以外，在函数被调用时，栈用来传递参数和返回值。
Index: ../Turtle/testing.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Show a testing strategy on the above -\n    you should give details of 【unit testing】, 【white/blackbox】 testing done on your code.\n    Describe any 【test-harnesses】 used.\n    In addition, give examples of the 【output】 of many 【different turtle programs】.\n\n1.Blackbox testing\n    In \"test\" directory, use several .c file to test if each component of parser/interpreter is worked functionally correctly.\n\n    use command \"make test\" to interpret this part.\n\n    (1) testrealloc.c tests if a table is successfully created to store the tokens of a program. Use 4 .ttl program sample\n    in \"DATA\" directory as input the test its functionality.\n\n    (2) testparsr.c tests if the parser is worked correctly to check grammar of a program is legal or not. Use the\n    same 4 DATA files as input as well.\n\n    (3) teststack.c tests if the stack is implementing the calculation correctly as Reversed Polish Notation. The\n    DATA/stack_testsample file gives examples of differnt input and output. The teststack.c uses this file as input, and\n    automatically compares the given output with the actual output of the stack calculator.\n\n    (4) testpoint.c tests if the basic interpreter is worked correctly, to interpret basic.c with simply FD and LT, RT instructions,\n     it is a simple version without file input, but call important drawing functions like drawFD() and turnLT(), to test\n     if its lines drawing length, direction and windows outfit etc is as expected.\n\n    (5) testinterp.c tests if the parser-interpreter is worked. Use 4 .ttl files as input, starting from basic.ttl to usevar.ttl,\n     check if the output shape is totally the same as expected at each stage, modify and improve the function set gradually.\n\n2.White-box testing\n\n    This program uses a testing framework called \"MinUnit\" to conduct white box testing.\n    The framework test parser functions by comparing the output of unit functions with the expected ones automatically.\n    Use different samples of .ttl programs in break-samples directory to test if a specific function is stable.\n\n    A MinUnit test case is a minimal unit test framework for C.\n    It is just a function that returns 0 (null) if the tests pass.\n    If the test fails, the function should return a string describing the failing test.\n    The mu_assert is simply a macro that returns a string if the expression passed to it is false.\n    The mu_runtest macro calls another test case and returns if that test case fails.\n\n    ( MinUnit's reference: http://www.jera.com/techinfo/jtns/jtn002.html#License )\n
===================================================================
--- ../Turtle/testing.txt	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ Turtle/testing.txt	(date 1615245742528)
@@ -24,17 +24,3 @@
 
     (5) testinterp.c tests if the parser-interpreter is worked. Use 4 .ttl files as input, starting from basic.ttl to usevar.ttl,
      check if the output shape is totally the same as expected at each stage, modify and improve the function set gradually.
-
-2.White-box testing
-
-    This program uses a testing framework called "MinUnit" to conduct white box testing.
-    The framework test parser functions by comparing the output of unit functions with the expected ones automatically.
-    Use different samples of .ttl programs in break-samples directory to test if a specific function is stable.
-
-    A MinUnit test case is a minimal unit test framework for C.
-    It is just a function that returns 0 (null) if the tests pass.
-    If the test fails, the function should return a string describing the failing test.
-    The mu_assert is simply a macro that returns a string if the expression passed to it is false.
-    The mu_runtest macro calls another test case and returns if that test case fails.
-
-    ( MinUnit's reference: http://www.jera.com/techinfo/jtns/jtn002.html#License )
Index: ../chap5/Recursion/Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>CC=gcc\n#CFLAGS=-Wall -Wextra -pedantic -std=c90 -O3\nCFLAGS=-Wall -Wextra -pedantic -std=c90 -g3 -fsanitize=undefined -fsanitize=address\nLDLIBS= -lm\n\nforest : neillsimplescreen.c neillsimplescreen.h forest.c\n\t$(CC) forest.c neillsimplescreen.c -o forest $(CFLAGS) $(LDLIBS)\n\ndemo_neillncurses : neillncurses.c neillncurses.h demo_neillncurses.c\n\t$(CC) demo_neillncurses.c neillncurses.c -o demo_neillncurses $(CFLAGS) $(LDLIBS) -lncurses\n
===================================================================
--- ../chap5/Recursion/Makefile	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ ../chap5/Recursion/Makefile	(date 1615245742720)
@@ -3,8 +3,10 @@
 CFLAGS=-Wall -Wextra -pedantic -std=c90 -g3 -fsanitize=undefined -fsanitize=address
 LDLIBS= -lm
 
-forest : neillsimplescreen.c neillsimplescreen.h forest.c
-	$(CC) forest.c neillsimplescreen.c -o forest $(CFLAGS) $(LDLIBS)
+maze : neillsimplescreen.c neillsimplescreen.h maze.c
+	$(CC) maze.c neillsimplescreen.c -o maze $(CFLAGS) $(LDLIBS)
+maze1 : neillsimplescreen.c neillsimplescreen.h maze1.c
+	$(CC) maze1.c neillsimplescreen.c -o maze1 $(CFLAGS) $(LDLIBS)
 
-demo_neillncurses : neillncurses.c neillncurses.h demo_neillncurses.c
-	$(CC) demo_neillncurses.c neillncurses.c -o demo_neillncurses $(CFLAGS) $(LDLIBS) -lncurses
+unlock_phone : neillsimplescreen.c neillsimplescreen.h unlock_phone.c
+	$(CC) unlock_phone.c neillsimplescreen.c -o unlock_phone $(CFLAGS) $(LDLIBS)
\ No newline at end of file
Index: ../Turtle/minunit.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* MinUnit -- a minimal unit test framework for C.\n * Reference from http://www.jera.com/techinfo/jtns/jtn002.html */\n#define mu_assert(message, test) do { if (!(test)) return message; } while (0)\n#define mu_run_test(test) do { char *message = test(); tests_run++; \\\n                                if (message) return message; } while (0)\nextern int tests_run;\n\n#include \"General/general.h\"
===================================================================
--- ../Turtle/minunit.h	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ Turtle/break-samples/UnitTest/minunit.h	(date 1615245742508)
@@ -5,4 +5,4 @@
                                 if (message) return message; } while (0)
 extern int tests_run;
 
-#include "General/general.h"
\ No newline at end of file
+#include "../../General/general.h"
\ No newline at end of file
Index: ../Turtle/unittest.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Parser/parser.h\"\n#include \"minunit.h\"\n/* PS: It cannot run for now :-( */\nstatic char * test_main();\nint main(int argc, const char* argv[])\n{\n   int tests_run = 0;\n    Program *p;\n    FILE* fp;\n    test();\n\n    fp = nfopen((char*)filename, \"r\");\n    if (argc != 2) {\n        fprintf(stderr, \"Usage : %s <filename>\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n    if(fp){\n        while(fscanf(fp, \"%s\", p->wds[p->numTk++])==1){\n            if(p->numTk >= p->maxnumTk){\n                p->wds = (char**) n2drecalloc((void**)p->wds, p->maxnumTk, SCALEFACTOR * p->maxnumTk,\n                                              FIXEDTOKENSIZE, FIXEDTOKENSIZE, sizeof(char));\n                p->maxnumTk = p->maxnumTk * SCALEFACTOR;\n            }\n        }\n    }\n    fclose(fp);\n\n\n    Main(prog);\n    /* Skip an empty line, move to the start of next sample */\n    if(fgetc(fp) == 1){\n        /* Clear the prog table */\n        prog_free(prog);\n    }\n\n\n    char *result = all_tests();\n    if (result != 0) {\n        printf(\"%s\\n\", result);\n    } else {\n        printf(\"ALL TESTS PASSED\\n\");\n    }\n    printf(\"Tests run: %d\\n\", tests_run);\n\n\n    return result != 0;\n}\n\n\nstatic char * test_main() {\n    mu_assert(\"error, Expecting a { ? \", p->wds[0] == \"{\");\n    return 0;\n}\n\nstatic char * all_tests() {\n    mu_run_test(test_main);\n    return 0;\n}
===================================================================
--- ../Turtle/unittest.c	(revision fd81ff239ec046ff2d49904e986c4bc35ff2fe66)
+++ Turtle/break-samples/unittest.c	(date 1615245742500)
@@ -1,5 +1,5 @@
-#include "Parser/parser.h"
-#include "minunit.h"
+#include "../Parser/parser.h"
+#include "UnitTest/minunit.h"
 /* PS: It cannot run for now :-( */
 static char * test_main();
 int main(int argc, const char* argv[])
Index: Hashing/test3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Hashing/test3.c	(date 1615245742472)
+++ Hashing/test3.c	(date 1615245742472)
@@ -0,0 +1,58 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <time.h>
+#define SEED 131
+unsigned int Hash1(void* key, int keySize, int size_hashArray);
+unsigned int Hash2(void* key, int keySize, int size_hashArray);
+
+int main()
+{
+    void *key01,*key02,*key03;
+    int i;
+    double j;
+    char* str="abcfdx";
+    srand(time(NULL));
+    i = rand()%20;
+    j=(double)1/i;
+    key01 = &j;
+    key02 = &i;
+    key03 = str;
+    for(i=0;i<1000;i++){
+
+    }
+
+    printf("%d %d %d.\n",Hash1(key01,4,17),Hash1(key02,4,17),Hash1(key03,0,17));
+    printf("%d %d %d.\n",Hash2(key01,4,17),Hash2(key02,4,17),Hash2(key03,0,17));
+
+    return 0;
+}
+
+unsigned int Hash1(void* key, int keySize, int size_hashArray)
+{
+    unsigned int hash = 0;
+    char* p=key;
+    int i=0;
+    while( i++ < keySize || (keySize==0 && *p!='\0')){
+        hash = hash * SEED + *(p++);
+    }
+    return hash % size_hashArray;
+}
+
+unsigned int Hash2(void* key, int keySize, int size_hashArray)
+{
+    unsigned int hash = 0;
+    char* p=key;
+    int i=0;
+    while( i++ < keySize || (keySize==0 && *p!='\0')){
+        if ((i & 1) == 0)
+        {
+            hash ^= ((hash << 7) ^ (*p++) ^ (hash >> 3));
+        }
+        else
+        {
+            hash ^= (~((hash << 11) ^ (*p++) ^ (hash >> 5)));
+        }
+    }
+    return (hash % size_hashArray);
+}
diff --git ../Turtle/Interp/interp.h Turtle/Interp/interp.h
rename from ../Turtle/Interp/interp.h
rename to Turtle/Interp/interp.h
diff --git ../Turtle/break-samples/UnitTest/breakInstruction/nofd3.ttl Turtle/break-samples/UnitTest/breakInstruction/nofd3.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstruction/nofd3.ttl
rename to Turtle/break-samples/UnitTest/breakInstruction/nofd3.ttl
diff --git ../Turtle/Interp/pars-interp.h Turtle/Interp/pars-interp.h
rename from ../Turtle/Interp/pars-interp.h
rename to Turtle/Interp/pars-interp.h
diff --git ../Turtle/Parser/parser.h Turtle/Parser/parser.h
rename from ../Turtle/Parser/parser.h
rename to Turtle/Parser/parser.h
diff --git ../Turtle/Parser/parser.c Turtle/Parser/parser.c
rename from ../Turtle/Parser/parser.c
rename to Turtle/Parser/parser.c
diff --git ../Turtle/break-samples/UnitTest/breakInstruction/nofd1.ttl Turtle/break-samples/UnitTest/breakInstruction/nofd1.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstruction/nofd1.ttl
rename to Turtle/break-samples/UnitTest/breakInstruction/nofd1.ttl
diff --git ../Turtle/General/general.h Turtle/General/general.h
rename from ../Turtle/General/general.h
rename to Turtle/General/general.h
diff --git ../Turtle/break-samples/UnitTest/breakInstruction/undefinedVar.ttl Turtle/break-samples/UnitTest/breakInstruction/undefinedVar.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstruction/undefinedVar.ttl
rename to Turtle/break-samples/UnitTest/breakInstruction/undefinedVar.ttl
diff --git ../Turtle/General/general.c Turtle/General/general.c
rename from ../Turtle/General/general.c
rename to Turtle/General/general.c
diff --git ../Turtle/Realloc/realloc.h Turtle/Realloc/realloc.h
rename from ../Turtle/Realloc/realloc.h
rename to Turtle/Realloc/realloc.h
diff --git ../Turtle/Realloc/realloc.c Turtle/Realloc/realloc.c
rename from ../Turtle/Realloc/realloc.c
rename to Turtle/Realloc/realloc.c
diff --git ../Turtle/break-samples/breakPollish.ttl Turtle/break-samples/breakPollish.ttl
rename from ../Turtle/break-samples/breakPollish.ttl
rename to Turtle/break-samples/breakPollish.ttl
diff --git ../Turtle/break-samples/breakDo.ttl Turtle/break-samples/breakDo.ttl
rename from ../Turtle/break-samples/breakDo.ttl
rename to Turtle/break-samples/breakDo.ttl
diff --git ../Turtle/break-samples/breakMain.ttl Turtle/break-samples/breakMain.ttl
rename from ../Turtle/break-samples/breakMain.ttl
rename to Turtle/break-samples/breakMain.ttl
diff --git ../Turtle/break-samples/breakInstrctlst.ttl Turtle/break-samples/breakInstrctlst.ttl
rename from ../Turtle/break-samples/breakInstrctlst.ttl
rename to Turtle/break-samples/breakInstrctlst.ttl
diff --git ../Turtle/break-samples/breakSet.ttl Turtle/break-samples/breakSet.ttl
rename from ../Turtle/break-samples/breakSet.ttl
rename to Turtle/break-samples/breakSet.ttl
diff --git ../Turtle/break-samples/breakInstruction.ttl Turtle/break-samples/breakInstruction.ttl
rename from ../Turtle/break-samples/breakInstruction.ttl
rename to Turtle/break-samples/breakInstruction.ttl
diff --git ../forestFire/forest.c forestFire/forest.c
rename from ../forestFire/forest.c
rename to forestFire/forest.c
diff --git ../Turtle/DATA/stack_testsample Turtle/DATA/stack_testsample
rename from ../Turtle/DATA/stack_testsample
rename to Turtle/DATA/stack_testsample
diff --git ../Turtle/DATA/nested.ttl Turtle/DATA/nested.ttl
rename from ../Turtle/DATA/nested.ttl
rename to Turtle/DATA/nested.ttl
diff --git ../Turtle/DATA/usevar.ttl Turtle/DATA/usevar.ttl
rename from ../Turtle/DATA/usevar.ttl
rename to Turtle/DATA/usevar.ttl
diff --git ../Turtle/DATA/loop.ttl Turtle/DATA/loop.ttl
rename from ../Turtle/DATA/loop.ttl
rename to Turtle/DATA/loop.ttl
diff --git ../Turtle/DATA/basic.ttl Turtle/DATA/basic.ttl
rename from ../Turtle/DATA/basic.ttl
rename to Turtle/DATA/basic.ttl
diff --git ../Turtle/test/testparser.c Turtle/test/testparser.c
rename from ../Turtle/test/testparser.c
rename to Turtle/test/testparser.c
diff --git ../Turtle/test/testpoint.c Turtle/test/testpoint.c
rename from ../Turtle/test/testpoint.c
rename to Turtle/test/testpoint.c
diff --git ../Turtle/test/testrealloc.c Turtle/test/testrealloc.c
rename from ../Turtle/test/testrealloc.c
rename to Turtle/test/testrealloc.c
diff --git ../forestFire/data/neillsimplescreen.h forestFire/data/neillsimplescreen.h
rename from ../forestFire/data/neillsimplescreen.h
rename to forestFire/data/neillsimplescreen.h
diff --git ../forestFire/data/neillsimplescreen.c forestFire/data/neillsimplescreen.c
rename from ../forestFire/data/neillsimplescreen.c
rename to forestFire/data/neillsimplescreen.c
diff --git ../Turtle/test/testinterp.c Turtle/test/testinterp.c
rename from ../Turtle/test/testinterp.c
rename to Turtle/test/testinterp.c
diff --git ../Turtle/test/teststack.c Turtle/test/teststack.c
rename from ../Turtle/test/teststack.c
rename to Turtle/test/teststack.c
diff --git ../forestFire/data/demo_neillsimplescreen.c forestFire/data/demo_neillsimplescreen.c
rename from ../forestFire/data/demo_neillsimplescreen.c
rename to forestFire/data/demo_neillsimplescreen.c
diff --git ../forestFire/feedback/personal forestFire/feedback/personal
rename from ../forestFire/feedback/personal
rename to forestFire/feedback/personal
diff --git ../forestFire/feedback/general forestFire/feedback/general
rename from ../forestFire/feedback/general
rename to forestFire/feedback/general
diff --git ../forestFire/feedback/ExampleFromNeill.c forestFire/feedback/ExampleFromNeill.c
rename from ../forestFire/feedback/ExampleFromNeill.c
rename to forestFire/feedback/ExampleFromNeill.c
diff --git ../Turtle/Interp/SDL/neillsdl2.h Turtle/Interp/SDL/neillsdl2.h
rename from ../Turtle/Interp/SDL/neillsdl2.h
rename to Turtle/Interp/SDL/neillsdl2.h
diff --git ../Turtle/Interp/SDL/neillsdl2.c Turtle/Interp/SDL/neillsdl2.c
rename from ../Turtle/Interp/SDL/neillsdl2.c
rename to Turtle/Interp/SDL/neillsdl2.c
diff --git ../Turtle/Interp/Point/point.h Turtle/Interp/Point/point.h
rename from ../Turtle/Interp/Point/point.h
rename to Turtle/Interp/Point/point.h
diff --git ../Turtle/Interp/Point/point.c Turtle/Interp/Point/point.c
rename from ../Turtle/Interp/Point/point.c
rename to Turtle/Interp/Point/point.c
diff --git ../Turtle/Interp/Stack/linked.c Turtle/Interp/Stack/linked.c
rename from ../Turtle/Interp/Stack/linked.c
rename to Turtle/Interp/Stack/linked.c
diff --git ../Turtle/Interp/Stack/stack.h Turtle/Interp/Stack/stack.h
rename from ../Turtle/Interp/Stack/stack.h
rename to Turtle/Interp/Stack/stack.h
diff --git ../Turtle/Interp/Varpool/varpool.h Turtle/Interp/Varpool/varpool.h
rename from ../Turtle/Interp/Varpool/varpool.h
rename to Turtle/Interp/Varpool/varpool.h
diff --git ../Turtle/Interp/Varpool/varpool.c Turtle/Interp/Varpool/varpool.c
rename from ../Turtle/Interp/Varpool/varpool.c
rename to Turtle/Interp/Varpool/varpool.c
diff --git ../Turtle/break-samples/UnitTest/breakDo/novarnum2.ttl Turtle/break-samples/UnitTest/breakDo/novarnum2.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/novarnum2.ttl
rename to Turtle/break-samples/UnitTest/breakDo/novarnum2.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/nofrom.ttl Turtle/break-samples/UnitTest/breakDo/nofrom.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/nofrom.ttl
rename to Turtle/break-samples/UnitTest/breakDo/nofrom.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/nolfbrace.ttl Turtle/break-samples/UnitTest/breakDo/nolfbrace.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/nolfbrace.ttl
rename to Turtle/break-samples/UnitTest/breakDo/nolfbrace.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/novarnum1.ttl Turtle/break-samples/UnitTest/breakDo/novarnum1.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/novarnum1.ttl
rename to Turtle/break-samples/UnitTest/breakDo/novarnum1.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/from-1.ttl Turtle/break-samples/UnitTest/breakDo/from-1.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/from-1.ttl
rename to Turtle/break-samples/UnitTest/breakDo/from-1.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/noto.ttl Turtle/break-samples/UnitTest/breakDo/noto.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/noto.ttl
rename to Turtle/break-samples/UnitTest/breakDo/noto.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/from1.5.ttl Turtle/break-samples/UnitTest/breakDo/from1.5.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/from1.5.ttl
rename to Turtle/break-samples/UnitTest/breakDo/from1.5.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/fromAtoB(A>B)2.ttl Turtle/break-samples/UnitTest/breakDo/fromAtoB(A>B)2.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/fromAtoB(A>B)2.ttl
rename to Turtle/break-samples/UnitTest/breakDo/fromAtoB(A>B)2.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/fromAtoA.ttl Turtle/break-samples/UnitTest/breakDo/fromAtoA.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/fromAtoA.ttl
rename to Turtle/break-samples/UnitTest/breakDo/fromAtoA.ttl
diff --git ../Turtle/Interp/interp.c Turtle/Interp/interp.c
rename from ../Turtle/Interp/interp.c
rename to Turtle/Interp/interp.c
diff --git ../Turtle/break-samples/UnitTest/breakDo/fromAtoB(A>B)1.ttl Turtle/break-samples/UnitTest/breakDo/fromAtoB(A>B)1.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/fromAtoB(A>B)1.ttl
rename to Turtle/break-samples/UnitTest/breakDo/fromAtoB(A>B)1.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/novar2.ttl Turtle/break-samples/UnitTest/breakDo/novar2.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/novar2.ttl
rename to Turtle/break-samples/UnitTest/breakDo/novar2.ttl
diff --git ../Turtle/break-samples/UnitTest/breakDo/novar1.ttl Turtle/break-samples/UnitTest/breakDo/novar1.ttl
rename from ../Turtle/break-samples/UnitTest/breakDo/novar1.ttl
rename to Turtle/break-samples/UnitTest/breakDo/novar1.ttl
diff --git ../Turtle/break-samples/UnitTest/breakSet/no:=2.ttl Turtle/break-samples/UnitTest/breakSet/no:=2.ttl
rename from ../Turtle/break-samples/UnitTest/breakSet/no:=2.ttl
rename to Turtle/break-samples/UnitTest/breakSet/no:=2.ttl
diff --git ../Turtle/break-samples/UnitTest/breakSet/no:=3.ttl Turtle/break-samples/UnitTest/breakSet/no:=3.ttl
rename from ../Turtle/break-samples/UnitTest/breakSet/no:=3.ttl
rename to Turtle/break-samples/UnitTest/breakSet/no:=3.ttl
diff --git ../Turtle/break-samples/UnitTest/breakSet/no:=1.ttl Turtle/break-samples/UnitTest/breakSet/no:=1.ttl
rename from ../Turtle/break-samples/UnitTest/breakSet/no:=1.ttl
rename to Turtle/break-samples/UnitTest/breakSet/no:=1.ttl
diff --git ../Turtle/break-samples/UnitTest/breakSet/novar.ttl Turtle/break-samples/UnitTest/breakSet/novar.ttl
rename from ../Turtle/break-samples/UnitTest/breakSet/novar.ttl
rename to Turtle/break-samples/UnitTest/breakSet/novar.ttl
diff --git ../Turtle/break-samples/UnitTest/breakMain/noinstruction.ttl Turtle/break-samples/UnitTest/breakMain/noinstruction.ttl
rename from ../Turtle/break-samples/UnitTest/breakMain/noinstruction.ttl
rename to Turtle/break-samples/UnitTest/breakMain/noinstruction.ttl
diff --git ../Turtle/break-samples/UnitTest/breakMain/nolfbrace2.ttl Turtle/break-samples/UnitTest/breakMain/nolfbrace2.ttl
rename from ../Turtle/break-samples/UnitTest/breakMain/nolfbrace2.ttl
rename to Turtle/break-samples/UnitTest/breakMain/nolfbrace2.ttl
diff --git ../Turtle/Interp/pars-interp.c Turtle/Interp/pars-interp.c
rename from ../Turtle/Interp/pars-interp.c
rename to Turtle/Interp/pars-interp.c
diff --git ../Turtle/break-samples/UnitTest/breakPolish/InfixNotation.ttl Turtle/break-samples/UnitTest/breakPolish/InfixNotation.ttl
rename from ../Turtle/break-samples/UnitTest/breakPolish/InfixNotation.ttl
rename to Turtle/break-samples/UnitTest/breakPolish/InfixNotation.ttl
diff --git ../Turtle/break-samples/UnitTest/breakPolish/PrefixNotation.ttl Turtle/break-samples/UnitTest/breakPolish/PrefixNotation.ttl
rename from ../Turtle/break-samples/UnitTest/breakPolish/PrefixNotation.ttl
rename to Turtle/break-samples/UnitTest/breakPolish/PrefixNotation.ttl
diff --git ../Turtle/break-samples/UnitTest/breakMain/nolfbrace3.ttl Turtle/break-samples/UnitTest/breakMain/nolfbrace3.ttl
rename from ../Turtle/break-samples/UnitTest/breakMain/nolfbrace3.ttl
rename to Turtle/break-samples/UnitTest/breakMain/nolfbrace3.ttl
diff --git ../Turtle/break-samples/UnitTest/breakPolish/undefinedVar.ttl Turtle/break-samples/UnitTest/breakPolish/undefinedVar.ttl
rename from ../Turtle/break-samples/UnitTest/breakPolish/undefinedVar.ttl
rename to Turtle/break-samples/UnitTest/breakPolish/undefinedVar.ttl
diff --git ../Turtle/break-samples/UnitTest/breakMain/nolfbrace1.ttl Turtle/break-samples/UnitTest/breakMain/nolfbrace1.ttl
rename from ../Turtle/break-samples/UnitTest/breakMain/nolfbrace1.ttl
rename to Turtle/break-samples/UnitTest/breakMain/nolfbrace1.ttl
diff --git ../Turtle/break-samples/UnitTest/breakPolish/noop2.ttl Turtle/break-samples/UnitTest/breakPolish/noop2.ttl
rename from ../Turtle/break-samples/UnitTest/breakPolish/noop2.ttl
rename to Turtle/break-samples/UnitTest/breakPolish/noop2.ttl
diff --git ../Turtle/break-samples/UnitTest/breakInstrctlst/extra_rtbrace.ttl Turtle/break-samples/UnitTest/breakInstrctlst/extra_rtbrace.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstrctlst/extra_rtbrace.ttl
rename to Turtle/break-samples/UnitTest/breakInstrctlst/extra_rtbrace.ttl
diff --git ../Turtle/break-samples/UnitTest/breakPolish/noop1.ttl Turtle/break-samples/UnitTest/breakPolish/noop1.ttl
rename from ../Turtle/break-samples/UnitTest/breakPolish/noop1.ttl
rename to Turtle/break-samples/UnitTest/breakPolish/noop1.ttl
diff --git ../Turtle/FormalGrammar Turtle/FormalGrammar
rename from ../Turtle/FormalGrammar
rename to Turtle/FormalGrammar
diff --git ../Turtle/break-samples/UnitTest/breakPolish/nosemicolon.ttl Turtle/break-samples/UnitTest/breakPolish/nosemicolon.ttl
rename from ../Turtle/break-samples/UnitTest/breakPolish/nosemicolon.ttl
rename to Turtle/break-samples/UnitTest/breakPolish/nosemicolon.ttl
diff --git ../Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace2.ttl Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace2.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace2.ttl
rename to Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace2.ttl
diff --git ../Turtle/break-samples/UnitTest/breakPolish/novarnum.ttl Turtle/break-samples/UnitTest/breakPolish/novarnum.ttl
rename from ../Turtle/break-samples/UnitTest/breakPolish/novarnum.ttl
rename to Turtle/break-samples/UnitTest/breakPolish/novarnum.ttl
diff --git ../Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace1.ttl Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace1.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace1.ttl
rename to Turtle/break-samples/UnitTest/breakInstrctlst/nortbrace1.ttl
diff --git ../Turtle/break-samples/UnitTest/breakInstruction/nodo.ttl Turtle/break-samples/UnitTest/breakInstruction/nodo.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstruction/nodo.ttl
rename to Turtle/break-samples/UnitTest/breakInstruction/nodo.ttl
diff --git ../Turtle/break-samples/UnitTest/breakInstruction/noset.ttl Turtle/break-samples/UnitTest/breakInstruction/noset.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstruction/noset.ttl
rename to Turtle/break-samples/UnitTest/breakInstruction/noset.ttl
diff --git ../Turtle/break-samples/UnitTest/breakInstruction/nofd2.ttl Turtle/break-samples/UnitTest/breakInstruction/nofd2.ttl
rename from ../Turtle/break-samples/UnitTest/breakInstruction/nofd2.ttl
rename to Turtle/break-samples/UnitTest/breakInstruction/nofd2.ttl
